php正则表达式的学习首要的是要记住它常用的
1》》》》元字符；
.     匹配换行符以外任意字符
\w    匹配字母或数字或下划线
\s    匹配任意的空白符
\d    匹配数字
\b    匹配单词的开始或结束
^     匹配字符串的开始
$     匹配字符串的结束
\W    \w的反义，匹配除字母数字或下划线的任意字符
\S    \s的反义，匹配除空白符的任意字符
\D    \d的反义，匹配除数字的任意字符
\B    \b的反义，匹配不是单词的开头或者结束的位置
[x]   匹配x字符，类似的[abc]匹配abc字符
[^x]  [x]的反义，匹配除x的任意字符，类似的[^abc]匹配除abc的任意字符
{5,}  匹配5位及5位以上
{5}   匹配5位
2》》》》选择与循环：
*     重复0次或无数次
+     重复1次或无数次
?     重复0次或1次
{n}   重复n次
{n,}  重复n次或无数次
{n,m} 重复n到m次
3》》》》分支（前面的匹配成功则不对后面的进行匹配）
|  或者
\d{5}-\d{4}|\d{5}
//错误写法
\d{5}|\d{5}-\d{4}

4》》》》模式修正符
i   匹配不区分大小写
U   匹配最近的字符串
贪婪匹配 （竟可能多的重复）
.*
懒惰匹配 （竟可能少的重复）
*?

preg_match() （只要匹配成功一次就会结束，可能不会执行完）
 函数用于进行正则表达式匹配，成功返回 1 ，否则返回 0 。例如：
<?php
if(preg_match("/php/i", "PHP is the web scripting language of choice.", $matches)){
    print "A match was found:". $matches[0];
} else {
    print "A match was not found.";
}
?>
preg_match_all()   (强制执行到结尾，一定会执行完)

5》》》》》
[\w-]  匹配数字或字母或下划线或汉字或短横杠
比如（^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$） 匹配邮箱地址
()     可以把小括号里的东西作为一个元字符


正则表达式常用整理：
验证账号，字母开头，允许 5-16 字节，允许字母数字下划线：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
验证账号，不能为空，不能有空格，只能是英文字母：^\S+[a-z A-Z]$
验证账号，不能有空格，不能非数字：^\d+$
验证用户密码，以字母开头，长度在 6-18 之间：^[a-zA-Z]\w{5,17}$
验证是否含有 ^%&',;=?$\ 等字符：[^%&',;=?$\x22]+
匹配Email地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
匹配腾讯QQ号：[1-9][0-9]{4,}
匹配日期，只能是 2004-10-22 格式：^\d{4}\-\d{1,2}-\d{1,2}$
匹配国内电话号码：^\d{3}-\d{8}|\d{4}-\d{7,8}$
评注：匹配形式如 010-12345678 或 0571-12345678 或 0831-1234567
匹配中国邮政编码：^[1-9]\d{5}(?!\d)$
匹配身份证：\d{14}(\d{4}|(\d{3}[xX])|\d{1})
评注：中国的身份证为 15 位或 18 位
不能为空且二十字节以上：^[\s|\S]{20,}

匹配由 26 个英文字母组成的字符串：^[A-Za-z]+$
匹配由 26 个大写英文字母组成的字符串：^[A-Z]+$
匹配由 26 个小写英文字母组成的字符串：^[a-z]+$
匹配由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$
匹配由数字、26个英文字母或者下划线组成的字符串：^\w+$
匹配空行：\n[\s| ]*\r
匹配任何内容：[\s\S]*
匹配中文字符：[\x80-\xff]+ 或者 [\xa1-\xff]+
只能输入汉字：^[\x80-\xff],{0,}$
匹配双字节字符(包括汉字在内)：[^\x00-\xff]

只能输入数字：^[0-9]*$
只能输入n位的数字：^\d{n}$
只能输入至少n位数字：^\d{n,}$
只能输入m-n位的数字：^\d{m,n}$
匹配正整数：^[1-9]\d*$
匹配负整数：^-[1-9]\d*$
匹配整数：^-?[1-9]\d*$
匹配非负整数（正整数 + 0）：^[1-9]\d*|0$
匹配非正整数（负整数 + 0）：^-[1-9]\d*|0$
匹配正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$
匹配负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$
匹配浮点数：^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
匹配非负浮点数（正浮点数 + 0）：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
匹配非正浮点数（负浮点数 + 0）：^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

匹配HTML标记的正则表达式（无法匹配嵌套标签）：<(\S*?)[^>]*>.*?</\1>|<.*? />
匹配网址 URL ：[a-zA-z]+://[^\s]*
匹配 IP 地址：((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)
匹配完整域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?

[\w-] ==》》 字母和符号-
\.    ==》》 符号.

PHP正则表达式修饰符的种类及介绍：
◆i ：如果在修饰符中加上"i"，则正则将会取消大小写敏感性，即"a"和"A" 是一样的。
◆m：默认的正则开始"^"和结束"$"只是对于正则字符串如果在修饰符中加上"m"，那么开始和结束将会指字符串的每一行：每一行的开头就是"^"，结尾就是"$"。
◆s：如果在修饰符中加入"s"，那么默认的"."代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！
◆x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。
◆e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。
◆A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说"/a/A"匹配"abcd"。
◆E：与"m"相反，如果使用这个修饰符，那么"$"将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。
◆U：和问号的作用差不多，用于设置"贪婪模式"。







