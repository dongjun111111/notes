1--》数据库中字段类型的选择：
字符串：utf8_general_ci

2--》InnoDB还是MyISAM，区别有以下几点：
1、首先我目前平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。
2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。
能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
3、从平台角度来说，经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，
这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。
如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为我平台上最小的一个数据库实例的数据量基本都是几十G大小。
4、从我接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的
，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。
5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，
让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。
6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，
虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。
7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，
非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。
当然Innodb也不是绝对不用，用事务的项目如模拟炒股项目，我就是用Innodb的，活跃用户20多万时候，也是很轻松应付了
，因此我个人也是很喜欢Innodb的，只是如果从数据库平台应用出发，我还是会首选MyISAM。

时间与日期格式：
MySQL数据类型	含义
date	        3字节，日期，格式：2014-09-18
time	        3字节，时间，格式：08:42:30
datetime	8字节，日期时间，格式：2014-09-18 08:42:30
timestamp	4字节，自动存储记录修改的时间
year	        1字节，年份
数值数据格式：
整型
MySQL数据类型	含义（有符号）
tinyint	        1字节，范围（-128~127）
smallint	2字节，范围（-32768~32767）
mediumint	3字节，范围（-8388608~8388607）
int	        4字节，范围（-2147483648~2147483647）
bigint	        8字节，范围（+-9.22*10的18次方）


字符串数据类型
MySQL数据类型	含义
char(n)	        固定长度，最多255个字符
varchar(n)      可变长度，最多65535个字符
tinytext        可变长度，最多255个字符
text            可变长度，最多65535个字符
mediumtext	可变长度，最多2的24次方-1个字符
longtext	可变长度，最多2的32次方-1个字符

binary关键字。只用于char和varchar值。当为列指定了该属性时，将以区分大小写的方式排序。与之相反，忽略binary属性时，将使用不区分大小写的方式排序。例如：
复制代码 代码如下:
hostname char(25) binary not null
unsigned关键字。上面定义的都是有符号的，当然了，也可以加上unsigned关键字，定义成无符号的类型，那么对应的取值范围就要翻翻了，比如：
tinyint unsigned的取值范围为0~255。
unique关键字。被赋予unique属性的列将确保所有值都有不同的值，只是null值可以重复。一般会指定一个列为unique，以确保该列的所有值都不同。


+++++++++为了给高并发情况下的MySQL进行更好的优化，有必要了解一下MySQL查询更新时的锁表机制。+++++++++

一、概述
MySQL有三种锁的级别：页级、表级、行级。
MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level
locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。
MySQL这3种锁的特性可大致归纳如下：
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

二、MyISAM表锁
MyISAM存储引擎只支持表锁，是现在用得最多的存储引擎。
但表级锁让多线程可以同时从数据表中读取数据，但是如果另一个线程想要写数据的话，就必须要先取得排他访问。正在更新数据时，必须要等到更新完成了，其他线程才能访问这个表。（这种机制造成了并发读写容易出现表锁争夺而导致阻塞访问）
1、查询表级锁争用情况
可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：
  mysql> show status like 'table%';
  +―――――――C+―――-+
  | Variable_name | Value |
  +―――――――C+―――-+
  | Table_locks_immediate | 76939364 |  （表示可以立即获取锁的次数）
  | Table_locks_waited | 305089 |  （表示不能立即获取锁，需要等待锁的次数;）        
  +―――――――C+―――-+
  2 rows in set (0.00 sec)
  Table_locks_waited/(Table_locks_immediate+Table_locks_waited)
  这个比例值越大说明表级锁争用的情况越严重。
  例：比例值=0.01说明100次进程里就有一次是需要等待锁的进程；

2、MySQL表级锁的锁模式
MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write
Lock）。MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
所以对MyISAM表进行操作，会有以下情况：
a、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。
b、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。

3、并发插入
原则上数据表有一个读锁时，其它进程无法对此表进行更新操作，但在一定条件下，MyISAM表也支持查询和插入操作的并发进行。
MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。
a、当concurrent_insert设置为0时，不允许并发插入。
b、当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
c、当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。
4、MyISAM的锁调度
由于MySQL认为写请求一般比读请求要重要，所以如果有读写请求同时进行的话，MYSQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段中存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞。
我们可以通过一些设置来调节MyISAM的调度行为：
a、通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
b、通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
c、通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。
    上面3种方法都是要么更新优先，要么查询优先的方法。这里要说明的就是，不要盲目的给mysql设置为读优先，因为一些需要长时间运行的查询操作，也会使写进程“饿死”。只有根据你的实际情况，来决定设置哪种操作优先。
    这些方法还是没有从根本上同时解决查询和更新的问题。在一个有大数据量高并发表的mysql里，我们还可采用另一种策略来进行优化，那就是通过mysql主从（读写）分离来实现负载均衡，这样可避免优先哪一种操作从而可能导致另一种操作的堵塞。下面将用一个篇幅来说明mysql的读写分离技术。

MyISAM使用的是 flock 类的函数，直接就是对整个文件进行锁定（叫做文件锁定），InnoDB使用的是 fcntl 类的函数，可以对文件中局部数据进行锁定（叫做行锁定），所以区别就是在这里。
另外MyISAM的数据表是按照单个文件存储的，可以针对单个表文件进行锁定，但是InnoDB是一整个文件，把索引、数据、结构全部保存在 ibdata 文件里，所以必须用行锁定。
死锁
所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中,
因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.
此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.
表级锁不会产生死锁.所以解决死锁主要还是真对于最常用的InnoDB.
遇到死锁的处理方式

mysql -uxxx -pxxx -h服务器ip --port=服务器端口;（如果服务器设置了ip和端口访问的话，一定要带ip和端口）

mysql> show processlist; #查看正在执行的sql （show full processlist;查看全部sql）
mysql> kill id #杀死sql进程；
如果进程太多找不到，就重启mysql吧
/ect/init.d/mysql restart 
或/ect/init.d/mysql stop（如果关不掉就直接kill -9 进程id）  再/ect/init.d/mysql start 
去看看mysql日志文件是否保存死锁日志：
常用目录：/var/log/mysqld.log；（该目录还有其它相关日志文件就都看看）
怎么解决还是要看具体什么问题.


+++++++++++mysql_pconnect用法和mysql_connect类似： +++++++++++
复制代码 代码如下:

<?php 
$conn = mysql_pconnect($host,$user,$pwd); 
mysql_select_db($dbname,$conn); 
$result=mysql_query("select * from table_name where col_id ='test_id'", $conn); 
$result_detail=mysql_fetch_array($result); 
$item = $result_detail['col_id']; 
?> 


备注：作为高并发处理数据库请求时，使用mysql_pconnect并不是一个很好的选择，此时可以考虑缓存及分步式等问题。

PHP持久连接mysql_pconnect()函数可以提高效率比拼JSP 

函数用法： 

复制代码 代码如下:

$dbHost = "localhost"; 
$dbUser = "root"; 
$dbPwd = ""; 
$dbName = "zhoutang"; 
$strSQL = "update tblUser set UserLC=UserLC+1 where UserID=100"; 
$link = mysql_connect($dbHost, $dbUser, $dbPwd) or die('Could not connect: ' .mysql_error()); 
mysql_select_db($dbName); 
mysql_query($strSQL); 
mysql_close($link); 


用法和mysql_connect ()类似，只是有两个区别：

第一， mysql_pconnect（）会先尝试寻找一个在同一个主机上用同样的用户名和密码已经打开的持久连接，如果找到，刚返回此链接的连接标识符而不打开新连接；

第二，当函数执行后，SQL服务器的连接不会被关闭，此连接将保持打开以备以后使用。 

mysql_pconnect（）函数可以大大的提高MYSQL效率，不过，此连接不自动关闭，也会造成一些问题，请注意将不用的连接即时关闭，以避免不必要的错误发生。 

其实，我以前写过PHP持久连接数据库的函数mysql_pconnect(),只是没有做任何的测试，今天做了一个小小的测试，果然真的不错，尤其是连接远程数据库的时候，效果更是非常的明显。 

下面再写一下PHP持久连接数据库存函数的应用方法（一个简单的不能再简单的MYSQL类） 

复制代码 代码如下:

<?php 
class mysql{ 
private $host; 
private $user; 
private $pw; 
private $dbname; 
private $code; 
public function __construct($host,$user,$pw,$dbname,$code){ 
$this->host=$host; 
$this->user=$user; 
$this->pw=$pw; 
$this->dbname=$dbname; 
$this->code=$code; 
$this->conn(); 
} 
public function conn(){ 
$conn=mysql_pconnect($this->host,$this->user,$this->pw) or die("links error");//持久连接 
mysql_select_db($this->dbname,$conn); 
mysql_query("SET NAMES {$this->code}"); 
} 
public function query($sql){ 
$result=mysql_query($sql); 
return $result; 
} 
} 
?> 


+++++++++MySQL CAST与CONVERT 函数的用法+++++++++++
MySQL 的CAST()和CONVERT()函数可用来获取一个类型的值，
并产生另一个类型的值。两者具体的语法如下：
CAST(value as type);
CONVERT(value, type);

++++++SQL笔试题：公司员工与部门查询++++++++++++
建表：
DEPARTMENTS:
DEPARTMENT_ID(primary key),
DEPARTMENT_NAME,
LOCATION
EMPLOYEES:
EMPLOYEE_ID(primary key),
EMPLOYEE_NAME,
EMPLOYEE_JOB,
MANAGER,
SALARY,
DEPARTMENT_ID
列出EMPLOYEES表中各部门的部门号，最高工资，最低工资
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID from EMPLOYEES group by DEPARTMENT_ID;
列出EMPLOYEES表中各部门EMPLOYEE_JOB为'CLERK'的员工的最低工资，最高工资
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID as 部门号 from EMPLOYEES where EMPLOYEE_JOB = 'CLERK' group by DEPARTMENT_ID;
对于EMPLOYEES中最低工资小于1000的部门，列出EMPLOYEE_JOB为'CLERK'的员工的部门号，最低工资，最高工资
view sourceprint?
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID as 部门号 from EMPLOYEES as b
where EMPLOYEE_JOB ='CLERK' and 1000>(select min(SALARY) from EMPLOYEES as a where a.DEPARTMENT_ID = b.DEPARTMENT_ID) group by b.DEPARTMENT_ID
根据部门号由高而低，工资有低而高列出每个员工的姓名，部门号，工资
select DEPARTMENT_ID as 部门号,EMPLOYEE_NAME as 姓名,SALARY as 工资 from EMPLOYEES order by DEPARTMENT_ID desc,SALARY asc
写出对上题的另一解决方法
还没想到，如果你又答案，请联系www.nowamagic.net，我的联系方式在网站首页。
列出'张三'所在部门中每个员工的姓名与部门号
select EMPLOYEE_NAME,DEPARTMENT_ID from EMPLOYEES where DEPARTMENT_ID = (select DEPARTMENT_ID from EMPLOYEES where EMPLOYEE_NAME = '张三')
列出每个员工的姓名，工作，部门号，部门名
select EMPLOYEE_NAME,EMPLOYEE_JOB,EMPLOYEES.DEPARTMENT_ID,DEPARTMENTS.DEPARTMENT_NAME from EMPLOYEES,DEPARTMENTS where EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
列出EMPLOYEES中工作为'CLERK'的员工的姓名，工作，部门号，部门名
select EMPLOYEE_NAME,EMPLOYEE_JOB,DEPARTMENTS.DEPARTMENT_ID,DEPARTMENT_NAME from EMPLOYEES,DEPARTMENTS where DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID and DEPARTMENT_JOB = 'CLERK'
对于EMPLOYEES中有管理者的员工，列出姓名，管理者姓名（管理者外键为MANAGER）
select a.EMPLOYEE_NAME as 姓名,b.EMPLOYEE_NAME as 管理者 from EMPLOYEES as a,EMPLOYEES as b where a.MANAGER is not null and a.MANAGER = b.EMPLOYEE_ID
对于DEPARTMENTS表中，列出所有部门名，部门号，同时列出各部门工作为'CLERK'的员工名与工作
select DEPARTMENT_NAME as 部门名,DEPARTMENTS.DEPARTMENT_ID as 部门号,EMPLOYEE_NAME as 员工名,EMPLOYEE_JOB as 工作 from DEPARTMENTS,EMPLOYEES
where DEPARTMENTS.DEPARTMENT_ID *= EMPLOYEES.DEPARTMENT_ID and EMPLOYEE_JOB = 'CLERK'
对于工资高于本部门平均水平的员工，列出部门号，姓名，工资，按部门号排序
select a.DEPARTMENT_ID as 部门号,a.EMPLOYEE_NAME as 姓名,a.SALARY as 工资 from EMPLOYEES as a
where a.SALARY>(select avg(SALARY) from EMPLOYEES as b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) order by a.DEPARTMENT_ID
对于EMPLOYEES，列出各个部门中平均工资高于本部门平均水平的员工数和部门号，按部门号排序
select count(a.SALARY) as 员工数,a.DEPARTMENT_ID as 部门号 from EMPLOYEES as a
where a.SALARY>(select avg(SALARY) from EMPLOYEES as b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) group by a.DEPARTMENT_ID order by a.DEPARTMENT_ID
对于EMPLOYEES中工资高于本部门平均水平，人数多与1人的，列出部门号，人数，按部门号排序
select count(a.EMPLOYEE_ID) as 员工数,a.DEPARTMENT_ID as 部门号,avg(SALARY) as 平均工资 from EMPLOYEES as a
where (select count(c.EMPLOYEE_ID) from EMPLOYEES as c where c.DEPARTMENT_ID = a.DEPARTMENT_ID and c.SALARY>(select avg(SALARY) from EMPLOYEES as b where c.DEPARTMENT_ID = b.DEPARTMENT_ID))>1
group by a.DEPARTMENT_ID order by a.DEPARTMENT_ID
对于EMPLOYEES中低于自己工资至少5人的员工，列出其部门号，姓名，工资，以及工资少于自己的人数
view sourceprint?
select a.DEPARTMENT_ID,a.EMPLOYEE_NAME,a.SALARY,(select count(b.EMPLOYEE_NAME) from EMPLOYEES as b where b.SALARY < a.SALARY) as 人数 from EMPLOYEES as a
where (select count(b.EMPLOYEE_NAME) from EMPLOYEES as b where b.SALARY<a.SALARY)>5

++++++取出数据库后10条数据++++++++
一种方法是数据库记录倒序排序，然后用limit 10子句获取10条。
 SELECT title AS TITLE FROM news ORDER BY id DESC LIMIT 10;
也可以取得最大记录的id，然后在WHERE子句减去10。
SELECT temp.title as 标题 FROM news AS temp WHERE news_id > (SELECT MAX(id) FROM news) - 10;


+++++++mysql_real_escape_string() 函数+++++++++++
mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。
保护数据库的安全――对即将运行于数据库的SQL语句进行安全性预处理.

常见数据库端口号 
MySQL: 3306
SQL Server: 1433
Oracle: 1521

常见协议端口号 
HTTP: 80
FTP: 20用于数据连接, 21用于端口连接
SSH: 22
Telnet: 23
HTTPS: 443

使用心得：
SQL语句用双引号，其中的值都用单引号，例如"INSERT INTO gril SET money='{$iMaxMoney}',age='18′"
用mysqli扩展代替mysql扩展
用mysqli_real_escape_string和mysqli_escape_string处理传出sql语句中的变量
用mysqli_set_charset(mysqli->set_charset)代替 query "SET NAMES"
联合查询(JOIN)之前，考虑下各个表的数据量，不合适的话应该分开查，尤其是有缓存可用的时候
很多地方需要记录发生时间，但不是每一个表都需要，同样，不是每一个表都需要一个自增量作主键
很多时候为integer类型加上unsigned是很好的
INERT DELEYED、INSERT IGNORE、SELECT DISTINCT…这种语句通常有意想不到的好效果
varchar类型并不是不能超过255长度，而是超过了255，这个字段就不能建立索引了，所以，看你的实际需要了


使用ip2long() 和long2ip()函数来把IP地址转化成整型存储到数据库里。
这种方法把存储空间降到了接近四分之一(char(15)的15个字节对整形的4个字节)，
计算一个特定的地址是不是在一个区段内页更简单了， 而且加快了搜索和排序的速度
(虽然有时仅仅是快了一点)。


+++++++++Mysql如何导入大SQL数据文件++++++
1、修改配置文件：一般默认配置是：1048576/1024/1024 = 1M
windows中修改my.ini文件，在linux中修改my.cnf文件.
C:\Documents and Settings\All Users\Application Data\MySQL\MySQL Server 5.5\my.ini(安装mysql时的,指定的数据文件目录)
修改max_allowed_packet值:
max_allowed_packet=500M;//根据情况选择
修改配置文件后,重启mysql
重启mysql后,在查看修改后的max_allowed_packet值
2、指定字符集编码：登录时指定字符集编码
mysql -uroot -P3308 -p123456 - -default-character-set=utf8 (-P是指指定端口号)
3、导入sql：最后通过source命令，即可成功导入:
source  E:ydj\test.sql


+++++++9个MySQL面试题++++++
1、如何确定 MySQL 是否处于运行状态？
Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status。
然后看看输出即可。
2、如何开启或停止 MySQL 服务？
运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务。
3、如何通过 Shell 登入 MySQL？
运行命令 mysql -u root -p
4、如何列出所有数据库？
运行命令 show databases;
5、如何切换到某个数据库并在上面工作？
运行命令 use database_name; 键入名为 database_name 的数据库。
6、如何列出某个数据库内所有表？
在当前数据库运行命令 show tables;
7、如何获取表内所有 Field 对象的名称和类型？
运行命令 describe table_name;
8、如何删除表？
运行命令 drop table table_name;
9、如何删除数据库？
运行命令 drop database database-name;
10、如何修改Root密码？
修改root密码对于某些特定设置是必不可少的，修改命令如下：
// 使用mysqladmin的password命令来修改（4.1格式）
$mysqladmin -u root password [新口令]
// 旧的修改口令的方法
$mysqladmin -u root -p [旧口令] 新口令 [敲回车后输入新口令，然后回车]
// 使用mysql的命令
$mysql -u root -p
mysql> use mysql;
mysql> update user set password=新口令 where User = ‘用户名’;
mysql> flush privileges;
mysql> quit


++++MYSQL数据库查询当天的信息(以ks_action_log表为例，时间字段是create_time,值是时间戳格式)++++++
select * from `ks_action_log` where date_format(from_UNIXTIME(`create_time`),'%Y-%m-%d') = date_format(now(),'%Y-%m-%d')
或者是：
select * from `ks_action_log` where to_days(date_format(from_UNIXTIME(`create_time`),'%Y-%m-%d')) = to_days(now())
如果该表里面的时间字段类型是DATETIME或TIMESTAMP,可以用一下几个sql语句：
select * from ks_action where to_days(`create_time`) = to_days(now());//查询今天
select * from `article` where to_days(now()) C to_days(`add_time`) <= 1; //查询昨天
select * from `article` where date_sub(curdate(), INTERVAL 7 DAY) <= date(`add_time`);//查询近7天
select * from `article` where date_format(`add_time`, ‘%Y%m') = date_format(curdate() , ‘%Y%m'); //查询本月
select * from `article` where period_diff(date_format(now() , ‘%Y%m') , date_format(`add_time`, ‘%Y%m')) =1; // 查询上一个月
对上面几个针对datetime类型的sql语句分析:
（1）to_days() 它是将具体的某一个日期或时间字符串转换到某一天所对应的unix时间戳。但是，
转换之后的数增加了1，这个粒度的查询是比较粗糙的，有时可能不能满足我们的查询要求，那么就需要使用细粒度的查询方法str_to_date函数了，下面将分析这个函数的用法。
（2）str_to_date()可以把字符串时间完全的翻译过来。
mysql> select str_to_date("2010-11-23 14:39:51",'%Y-%m-%d %H:%i:%s');
+--------------------------------------------------------+
| str_to_date("2010-11-23 14:39:51",'%Y-%m-%d %H:%i:%s') |
+--------------------------------------------------------+
| 2010-11-23 14:39:51                                    |
+--------------------------------------------------------+
具体案例：
select str_to_date(article.`add_time`,'%Y-%m-%d %H:%i:%s')
from article
where str_to_date(article.`add_time`,'%Y-%m-%d %H:%i:%s')>='2012-06-28 08:00:00' and str_to_date(article.`add_time`,'%Y-%m-%d %H:%i:%s')<='2012-06-28 09:59:59';


++++++学会设置MySQL数据库的五个常用参数++++++
(一)连接
连接通常来自Web服务器，下面列出了一些与连接有关的参数，以及该如何设置它们。
1、max_connections
这是Web服务器允许的最大连接数，记住每个连接都要使用会话内存(关于会话内存，文章后面有涉及)。
2、max_packet_allowed
最大数据包大小，通常等于你需要在一个大块中返回的最大数据集的大小，如果你在使用远程mysqldump，那它的值需要更大。
3、aborted_connects
检查系统状态的计数器，确定其没有增长，如果数量增长说明客户端连接时遇到了错误。
4、thread_cache_size
入站连接会在MySQL中创建一个新的线程，因为MySQL中打开和关闭连接都很廉价，速度也快，
它就没有象其它数据库，如Oracle那么多持续连接了，但线程预先创建并不会节约时间，
这就是为什么要MySQL线程缓存的原因了。
(二)查询缓存
MySQL中的缓存查询包括两个解析查询计划，以及返回的数据集，如果基础表数据或结构有变化，将会使查询缓存中的项目无效。
1、query_cache_min_res_unit
MySQL参数中query_cache_min_res_unit查询缓存中的块是以这个大小进行分配的，使用下面的公式计算查询缓存的平均大小，
根据计算结果设置这个变量，MySQL就会更有效地使用查询缓存，缓存更多的查询，减少内存的浪费。
2、query_cache_size
这个参数设置查询缓存的总大小。
3、query_cache_limit
这个参数告诉MySQL丢掉大于这个大小的查询，一般大型查询还是比较少见的，如运行一个批处理执行一个大型报表的统计，因此那些大型结果集不应该填满查询缓存。
qcache hit ratio = qcache_hits / (qcache_hits + com_select)
使用
SQL> show status like 'qcache%';
SQL> show status like 'com_%';
找到这些变量。
average query size = (query_cache_size - qcache_free_memory)/qcache_queries_in_cache
使用
SQL> show variables like 'query%';
qcache_* status variables you can get with:
SQL> show status like 'qcache%';
获取query_cache_size的值。
(三)临时表
内存速度是相当快的，因此我们希望所有的排序操作都在内存中进行，我们可以通过调整查询让结果集更小以实现内存排序，或将变量设置得更大。
tmp_table_size
max_heap_table_size
无论何时在MySQL中创建临时表，它都会使用这两个变量的最小值作为临界值，除了在磁盘上构建临时表外，还会创建许多会话，
这些会话会抢占有限制的资源，因此最好是调整查询而不是将这些参数设置得更高，同时，需要注意的是有BLOB或TEXT字段类型
的表将直接写入磁盘。 深入浅出MySQL双向复制技术
(四)会话内存
MySQL中每个会话都有其自己的内存，这个内存就是分配给SQL查询的内存，因此你想让它变得尽可能大以满足需要。但你不得不
平衡同一时间数据库内一致性会话的数量。这里显得有点黑色艺术的是MySQL是按需分配缓存的，因此，你不能只添加它们并乘以
会话的数量，这样估算下来比MySQL典型的使用要大得多。最佳做法是启动MySQL，连接所有会话，然后继续关注顶级会话的VIRT列，
mysqld行的数目通常保持相对稳定，这就是实际的内存总用量，减去所有的静态MySQL内存区域，就得到了实际的所有会话内存，然后除以会话的数量就得到平均值
1、read_buffer_size
缓存连续扫描的块，这个缓存是跨存储引擎的，不只是MyISAM表。
2、sort_buffer_size
执行排序缓存区的大小，最好将其设置为1M-2M，然后在会话中设置，为一个特定的查询设置更高的值。
3、join_buffer_size
执行联合查询分配的缓存区大小，将其设置为1M-2M大小，然后在每个会话中再单独按需设置。
4、read_rnd_buffer_size
用于排序和order by操作，最好将其设置为1M，然后在会话中可以将其作为一个会话变量设置为更大的值。
(五)慢速查询日志
慢速查询日志是MySQL很有用的一个特性。
1、log_slow_queries
MySQL参数中log_slow_queries参数在my.cnf文件中设置它，将其设置为on，默认情况下，MySQL会将文件放到数据目录，
文件以“主机名-slow.log”的形式命名，但你在设置这个选项的时候也可以为其指定一个名字。
2、long_query_time
默认值是10秒，你可以动态设置它，值从1到将其设置为on，如果数据库启动了，默认情况下，日志将关闭。截至5.1.21和
安装了Google补丁的版本，这个选项可以以微秒设置，这是一个了不起的功能，因为一旦你消除了所有查询时间超过1秒的
查询，说明调整非常成功，这样可以帮助你在问题变大之前消除问题SQL。
3、log_queries_not_using_indexes
开启这个选项是个不错的主意，它真实地记录了返回所有行的查询。
如果在增长请密切注意创建的线程，让你的线程缓存更大，对于2550或100的thread_cache_size，内存占用也不多。

+++++用rand()来实现随机查找+++++
在表tt_dvjobs中随机查询10条数据：
select * from `tt_dvjobs` ORDER BY rand() LIMIT 0 , 10;
实践证明改函数会导致查询性能非常低下，请慎用此函数！


++++MySQL btree索引与hash索引方式的区别+++++
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，
最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。但是现实中都很少用 Hash 索引，
用 B-Tree 索引比hash索引多得多。可以这样理解，BTREE索引是一种B树结构索引，里面的数据根据大小或者其它原因进行了各种编排，
查询时将数据与里面各节点的数据进行对比以快速找到目标。而hash索引是一种集合索引，它对要查询的数据都已经进行了hash处理，
并且把处理的结果与存储的位置对应了起来，这样当你查询某一个值时，它能根据这个值计算出一个与存储位置相关的结果，
从而实现快速命中目标。所以既然如此hash在命中高的同时也有很重要的劣势。
1、Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询，也不能使用匹配%，搜索查询，也不能进行排序操作
由于Hash索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，对于像where id>5或者where title like '%abc%'之类
的查询无能为力。而也正因为这样，对hash索引也不能进行排序。而这些都是很多数据读取操作中经常要使用的功能，所以多数索引仍会使用B-TREE索引。
2、联合索引里无法使用Hash索引
对于联合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，
所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
3、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
对于数据重复性比较高的列，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。
比如对用户的学历、职称、性别进行索引，这些字段值比较固定，hash索引时要定位某一条记录时就会非常麻烦，
会浪费多次表数据的访问，而造成整体性能低下。hash表更适合于唯一性高但又不要求进行排序或者取范围时用的索引，
这点让我想起来REDIS里的hash结构，你扔给他一个hash，键名为用户名，键值为用户的数据json结构，这个就非常适合
使用hash,因为hash会大大提高命中，所以REDIS里能有这么快的速度。
我看到网上有上有很多被转载的文件上都写有一点：Hash 索引在任何时候都不能避免表扫描（Hash 索引是将索引键通过
 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 
值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据
进行相应的比较，并得到相应的结果）。我觉得HASH之所以快就是采用了hash值去查找数据的方式，即便它进行所谓的“表扫描”，
也是一很优化的表扫描，不然hash的查询效率如何远高于B-TREE索引。



++++防止人为误操作MySQL数据库解决方法++++++
1、mysql帮助说明
1. [oldboy_c64 ~]# mysql --help|grep dummy
2.  -U, --i-am-a-dummy Synonym for option --safe-updates, -U.
3. i-am-a-dummy      FALSE
在mysql命令加上选项-U后，当发出没有WHERE或LIMIT关键字的UPDATE或DELETE时，mysql程序就会拒绝执行
2、指定-U登录测试
1. [oldboy_c64 ~]# mysql -uroot -poldboy123 -S /data/3306/mysql.sock -U
2. Welcome to the MySQL monitor. Commands end with ; or \g.
3. Your MySQL connection id is 14
4. Server version: 5.5.32-log MySQL Community Server (GPL)
5. Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
6. Oracle is a registered trademark of Oracle Corporation and/or its
7. affiliates. Other names may be trademarks of their respective
8. owners.
9. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
10. mysql> delete from oldboy.student;
11. ERROR 1175 (HY000): You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column
12. mysql> quit
13. Bye
提示：不加条件无法删除，目的达到。
3、做成别名防止老大和DBA误操作
1. [oldboy_c64 ~]# alias mysql='mysql -U'
2. [oldboy_c64 ~]# mysql -uroot -poldboy123 -S /data/3306/mysql.sock
3. Welcome to the MySQL monitor. Commands end with ; or \g.
4. Your MySQL connection id is 15
5. Server version: 5.5.32-log MySQL Community Server (GPL)
6. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
7. mysql> delete from oldboy.student;
8. ERROR 1175 (HY000): You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column
9. mysql> delete from oldboy.student where Sno=5;
10. Query OK, 1 row affected (0.02 sec)
11. mysql> quit
12. Bye
13. [oldboy_c64 ~]# echo "alias mysql='mysql -U'" >>/etc/profile
14. [oldboy_c64 ~]# . /etc/profile
15. [oldboy_c64 ~]# tail -1 /etc/profile
16. alias mysql='mysql -U'
结论：在mysql命令加上选项-U后，当发出没有WHERE或LIMIT关键字的UPDATE或DELETE时，mysql程序拒绝执行。


+++++MySQL设置允许远程登录数据库方法++++++
 开启 MySQL 的远程登陆帐号有两大步：
1、确定服务器上的防火墙没有阻止 3306 端口
 MySQL 默认的端口是 3306 ，需要确定防火墙没有阻止 3306 端口，否则远程是无法通过 3306 端口连接到 MySQL 的。
如果您在安装 MySQL 时指定了其他端口，请在防火墙中开启您指定的 MySQL 使用的端口号。
2、增加允许远程连接 MySQL 用户并授权
a.首先以 root 帐户登陆 MySQL
b.创建远程登陆用户并授权
> grant all PRIVILEGES on discuz.* to ted@'123.123.123.123' identified by '123456';
上面的语句表示将 discuz 数据库的所有权限授权给 ted 这个用户，允许 ted 用户在 123.123.123.123 这个 IP 进行远程登陆，并设置 ted 用户的密码为 123456 。
下面逐一分析所有的参数：
all PRIVILEGES 表示赋予所有的权限给指定用户，这里也可以替换为赋予某一具体的权限，例 如：select,insert,update,delete,create,drop 等，具体权限间用“,”半角逗号分隔。
discuz.* 表示上面的权限是针对于哪个表的，discuz 指的是数据库，后面的 * 表示对于所有的表，
由此可以推理出：对于全部数据库的全部表授权为“*.*”，对于某一数据库的全部表授权为
“数据库名.*”，对于某一数据库的某一表授 权为“数据库名.表名”。
ted 表示你要给哪个用户授权，这个用户可以是存在的用户，也可以是不存在的用户。
123.123.123.123 表示允许远程连接的 IP 地址，如果想不限制链接的 IP 则设置为“%”即可。
123456 为用户的密码。
执行了上面的语句后，再执行下面的语句，方可立即生效。
> flush privileges;
3.远程登陆MySql数据库
假设ip 为123.123.123.124的主机创建远程登陆用户并授权：
> grant all PRIVILEGES on discuz.* to ted@'123.123.123.123' identified by '123456';
在ip为123.123.123.123的主机上用 cmd打开终端，在终端上输入：
MySql -h123.123.123.124 -uted -p123456  
然后就登陆了ip 为123.123.123.124的数据库。


++++MySQL不同数据库不同数据表导入数据++++++
背景
现在有这么一个需求：
数据库A的user表需要导入到数据库B的account表
user表字段：uid,username,email,password,regdate,salt
account表字段：id,name,email,password,type,salt
导入的字段只有username,email,password,salt，并且regdate需要符合某个条件
下面分几种情况来写sql，主要区分insert into和replace into
情况
导入的数据在B库的表中完全不存在
直接insert into就好，使用replace into效果一样
INSERT INTO `B`.`account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`users`
WHERE regdate>1418313600
导入的数据部分存在
数据部分存在为了区分需要在两个表添加唯一索引，这个唯一索引(UNIQUE)必须是导入的字段里面的值
我在两个表中分别为username和name字段添加唯一索引
直接替换
replace into在操作的时候如果两表数据重复（必须定义UNIQUE），会先删掉那一行（注意是一整行），然后再执行insert into
造成的后果就是，account表中的type字段如果原来有值，会直接删掉，并重新插入，即变成默认值了
REPLACE INTO `B`.`account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`users`
WHERE regdate>1418313600
忽略重复
用IGNORE关键字，如果遇到重复，不会操作当前行
INSERT IGNORE INTO `B`.`account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`users`
WHERE regdate>1418313600
部分更新
比如果只想更新password和salt字段，可以用ON DUPLICATE KEY UPDATE
INSERT INTO `B`.`u_account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`bbs_ucenter_members`
WHERE regdate>1418313600 ON DUPLICATE KEY UPDATE PASSWORD=VALUES(PASSWORD),salt=VALUES(salt)

++++myisam表转换为innodb表++++++
请确保InnoDB开启，MySQL命令行下SHOW ENGINES命令查看
mysql> ALTER TABLE  boblog_history   ENGINE=InnoDB;
Query OK, 2808 rows affected (0.76 sec)
Records: 2808  Duplicates: 0  Warnings: 0


+++++++MySql存储过程及MySql常用流程控制语法++++++++
/*
该代码是创建了一个名叫"p4"的存储过程并设置了s1,s2,s3两个int型一个varchar型参数，还可以是其他数据类型，内部创建了x1,x2两个变量

DELIMITER是修改分隔符的
DELIMITER $$的意思是把默认分隔符";"换成"$$"，这样分段写的存储过程就能整个被执行，而不是被当成多条sql语句单独执行
创建完过程再将分隔符改回成";"

两种创建变量并赋值的方式
SET @变量名 = 值;
SELECT 值 INTO @变量名;
使用变量前必须先运行该变量赋值语句
过程内部还可以通过 "DECLARE 变量名 类型(字符串型要加范围) DEFAULT 值;" 来创建变量，但如此创建的变量只能在该过程内部访问

存储过程只有三种类型参数 IN,OUT,INOUT
调用过程时过程有几个参数传几个参数，只是IN型的参数可以传的是变量，可以是常量，而OUT和INOUT型的参数传的必须是变量
传给out，inout参数的变量值会随着在过程中改变在外部也改变，而给in参数的变量外部值则不受过程内变量值改变的影响
*/
DELIMITER $$

DROP PROCEDURE IF EXISTS `p4`$$

CREATE PROCEDURE `p4`(IN s1 INT,OUT s2 INT,INOUT s3 VARCHAR(10))
BEGIN
DECLARE x1 VARCHAR(10) DEFAULT 'this is x1'; 
DECLARE x2 VARCHAR(10) DEFAULT 'this is x2'; 
SET s1 = 11;
SET s2 = 22;
SET s3 = 'iss3';

/*
if语法
*/
IF s1 = 11 AND s2 = 12 THEN
SELECT s1,s2;
END IF;

IF s3 = 's3' OR s1 = s2 THEN
SELECT s3;
ELSE 
SELECT s1,s2,s3;
END IF;

/*
case语法
*/
CASE s3
WHEN 's1' THEN
SELECT 'this is s1';
WHEN 's2' THEN
SELECT 'this is s2';
ELSE
SELECT 'this is s3';
END CASE;

/*
while循环
*/
WHILE s1>1 DO
SET s1=s1-1;
END WHILE; 
SELECT s1;

/*
repeat循环语句
与while不同的是while满足条件就执行，repeat始终执行直到满足条件终止
*/
REPEAT  
SET s1 = s1-1; 
UNTIL s1=1  
END REPEAT; 
SELECT s1;


/*
LOOP循环
LOOP没有循环条件，会不停的循环直到遇到 "LEAVE ZiDingYi;" "ZiDingYi"是自定义的LOOP标记
*/
ZiDingYi:LOOP
SET s1 = s1+1;
IF s1 = 5 THEN
LEAVE ZiDingYi;
END IF;
END LOOP;
SELECT s1;


END$$

DELIMITER ;


SET @p_in=1; 
SET @p_out=2;
SET @p_inout = 's3';
SELECT 'Hello World1' INTO @p_4;

/*调用存储过程*/
CALL p4(@p_in,@p_out,@p_inout);
SELECT @p_in,@p_out,@p_inout,@p_4;


/*
存储过程如果只有一个语句则语句不用 begin...end包围
存储过程中可以直接使用外部定义的变量
存储过程中用set和select定义的变量就是全局的，执行该过程后内部用set和select定义的变量外部可以访问，其他过程也可以直接使用
*/
CREATE PROCEDURE p1()   SET @var='p1';  
CREATE PROCEDURE p2() SELECT CONCAT('Last procedure was ',@var);  
CALL p1();  
CALL p2(); 
SELECT @var;

CREATE PROCEDURE p3() SELECT CONCAT(@p3_var,' World');
SET @p3_var='Hello';
CALL p3();

/*删除存储过程*/
DROP PROCEDURE p4;
/*或者*/
DROP PROCEDURE IF EXISTS `p4`

/*查看该数据库下有哪些存储过程 test为数据库名*/
SELECT NAME FROM mysql.proc WHERE db='test';
/*或者*/
SHOW PROCEDURE STATUS WHERE db='test';

/*查看存储过程详细信息，包括创建语句*/
SHOW CREATE PROCEDURE p4;



++++mysql中mysql_fetch_assoc()++++++
mysql_fetch_assoc()从数据库中取出一行（只取一行）作为数组，那么可以用var_dump或者print_r输出,默认为id=1.
$res=mysql_query("select * from ks_zhiding where id>8");
$fff=mysql_fetch_assoc($res);
var_Dump($fff);
结果为：
array (size=3)
  'id' => string '9' (length=1)
  'rank' => string '9' (length=1)
  'name' => string 'aaa' (length=3)


++++mysql临时表+++++
CREATE TEMPORARY TABLE linshi_table (
    `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(20) DEFAULT NULL,
    PRIMARY KEY (`id`)
);
 
INSERT INTO linshi_table(NAME)VALUES('firstName');
UPDATE linshi_table SET NAME='updateName';
SELECT * FROM linshi_table;


DROP TABLE linshi_table;

/*
当前创建的临时表将在当前连接MySQL期间存在。当当前连接断开时，MySQL将自动删除表并释放所用的空间。当然可以在仍然连接的时候删除表并释放空间。
创建临时表很容易，给正常的CREATE TABLE语句加上TEMPORARY关键字
如果在创建名为linshi_table临时表时名为linshi_table的实体表在数据库中已经存在，Mysql临时表将屏蔽（隐藏）非临时表linshi_table
实体表隐藏后不管是查询，插入，更新，都是对临时表进行操作，实体表实际内容不受影响
*/


++order by 多个字段+++
（均未测试）
第一种：order by last_time desc ,id desc
第二种：select id,last_time from yourtablename group by last_time order by last_time desc,id desc


++MySQL搜索关键字所处位置先后排序+++
error_reporting(0);
date_default_timezone_set('PRC');
mysql_connect("localhost","root",'');
mysql_select_db("root");
$re=mysql_query("select * from ks_zhiding where name like '%a%' order by locate('a',name)");
while($rows=mysql_fetch_array($re)){
	echo $rows['name'].'<br>';
}
结果之一可以是：
aaa
change2


+++mysql_fetch_object()+++
实现类似mysql_fetch_array()一样的取数据的功能，但是它会把数据作为对象取出，访问方法可以是$row->to;
while($row=mysql_fetch_object($res)){
	echo $row->id;
}

++++char_length（）与length（）+++++
mysql中字符串长度有两个函数分别为char_length和length，前者可以计算unicode字符，包括中文等字符集的长度，
而length函数用来计算普通字符的长度，他会把一个中文字符的长度计算为2或3.
mysql> select length('的') as l, char_length('的') as cl;
+---+----+
| l | cl |
+---+----+
| 3 |  1 |
+---+----+
可以看到中文“的”的length为3，而char_length函数结果为1

+++sql对结果集进行重新编号+++++
$res=mysql_query("select  ((select count(1) from ks_zhiding where rank < t.rank) +1) as uid, rank,name from ks_zhiding as t where rank < 7 order by name");
while($row=mysql_fetch_array($res)){
    echo $row['uid'].'----'.$row['rank'].'----'.$row['name']."<br>";
}
结果如下：
uid  rank  name
1----1----bob
3----5----change2
2----4----ddd
4----6----gggrr


+++查询连续3天没有登录的人名+++++++
查询连续3天没有登录的人名
select name from table where id=(
select max(id) from table group by to_char(time,'yyyymmdd') having count(*)<3);