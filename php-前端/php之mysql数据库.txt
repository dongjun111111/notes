1--》数据库中字段类型的选择：
字符串：utf8_general_ci

2--》InnoDB还是MyISAM，区别有以下几点：
1、首先我目前平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。
2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。
能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
3、从平台角度来说，经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，
这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。
如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为我平台上最小的一个数据库实例的数据量基本都是几十G大小。
4、从我接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的
，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。
5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，
让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。
6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，
虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。
7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，
非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。
当然Innodb也不是绝对不用，用事务的项目如模拟炒股项目，我就是用Innodb的，活跃用户20多万时候，也是很轻松应付了
，因此我个人也是很喜欢Innodb的，只是如果从数据库平台应用出发，我还是会首选MyISAM。

时间与日期格式：
MySQL数据类型	含义
date	        3字节，日期，格式：2014-09-18
time	        3字节，时间，格式：08:42:30
datetime	8字节，日期时间，格式：2014-09-18 08:42:30
timestamp	4字节，自动存储记录修改的时间
year	        1字节，年份
数值数据格式：
整型
MySQL数据类型	含义（有符号）
tinyint	        1字节，范围（-128~127）
smallint	2字节，范围（-32768~32767）
mediumint	3字节，范围（-8388608~8388607）
int	        4字节，范围（-2147483648~2147483647）
bigint	        8字节，范围（+-9.22*10的18次方）


字符串数据类型
MySQL数据类型	含义
char(n)	        固定长度，最多255个字符
varchar(n)      可变长度，最多65535个字符
tinytext        可变长度，最多255个字符
text            可变长度，最多65535个字符
mediumtext	可变长度，最多2的24次方-1个字符
longtext	可变长度，最多2的32次方-1个字符

binary关键字。只用于char和varchar值。当为列指定了该属性时，将以区分大小写的方式排序。与之相反，忽略binary属性时，将使用不区分大小写的方式排序。例如：
复制代码 代码如下:
hostname char(25) binary not null
unsigned关键字。上面定义的都是有符号的，当然了，也可以加上unsigned关键字，定义成无符号的类型，那么对应的取值范围就要翻翻了，比如：
tinyint unsigned的取值范围为0~255。
unique关键字。被赋予unique属性的列将确保所有值都有不同的值，只是null值可以重复。一般会指定一个列为unique，以确保该列的所有值都不同。


+++++++++为了给高并发情况下的MySQL进行更好的优化，有必要了解一下MySQL查询更新时的锁表机制。+++++++++

一、概述
MySQL有三种锁的级别：页级、表级、行级。
MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level
locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。
MySQL这3种锁的特性可大致归纳如下：
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

二、MyISAM表锁
MyISAM存储引擎只支持表锁，是现在用得最多的存储引擎。
但表级锁让多线程可以同时从数据表中读取数据，但是如果另一个线程想要写数据的话，就必须要先取得排他访问。正在更新数据时，必须要等到更新完成了，其他线程才能访问这个表。（这种机制造成了并发读写容易出现表锁争夺而导致阻塞访问）
1、查询表级锁争用情况
可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：
  mysql> show status like 'table%';
  +―――――――C+―――-+
  | Variable_name | Value |
  +―――――――C+―――-+
  | Table_locks_immediate | 76939364 |  （表示可以立即获取锁的次数）
  | Table_locks_waited | 305089 |  （表示不能立即获取锁，需要等待锁的次数;）        
  +―――――――C+―――-+
  2 rows in set (0.00 sec)
  Table_locks_waited/(Table_locks_immediate+Table_locks_waited)
  这个比例值越大说明表级锁争用的情况越严重。
  例：比例值=0.01说明100次进程里就有一次是需要等待锁的进程；

2、MySQL表级锁的锁模式
MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write
Lock）。MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
所以对MyISAM表进行操作，会有以下情况：
a、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。
b、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。

3、并发插入
原则上数据表有一个读锁时，其它进程无法对此表进行更新操作，但在一定条件下，MyISAM表也支持查询和插入操作的并发进行。
MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。
a、当concurrent_insert设置为0时，不允许并发插入。
b、当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
c、当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。
4、MyISAM的锁调度
由于MySQL认为写请求一般比读请求要重要，所以如果有读写请求同时进行的话，MYSQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段中存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞。
我们可以通过一些设置来调节MyISAM的调度行为：
a、通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
b、通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
c、通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。
    上面3种方法都是要么更新优先，要么查询优先的方法。这里要说明的就是，不要盲目的给mysql设置为读优先，因为一些需要长时间运行的查询操作，也会使写进程“饿死”。只有根据你的实际情况，来决定设置哪种操作优先。
    这些方法还是没有从根本上同时解决查询和更新的问题。在一个有大数据量高并发表的mysql里，我们还可采用另一种策略来进行优化，那就是通过mysql主从（读写）分离来实现负载均衡，这样可避免优先哪一种操作从而可能导致另一种操作的堵塞。下面将用一个篇幅来说明mysql的读写分离技术。

MyISAM使用的是 flock 类的函数，直接就是对整个文件进行锁定（叫做文件锁定），InnoDB使用的是 fcntl 类的函数，可以对文件中局部数据进行锁定（叫做行锁定），所以区别就是在这里。
另外MyISAM的数据表是按照单个文件存储的，可以针对单个表文件进行锁定，但是InnoDB是一整个文件，把索引、数据、结构全部保存在 ibdata 文件里，所以必须用行锁定。
死锁
所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中,
因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.
此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.
表级锁不会产生死锁.所以解决死锁主要还是真对于最常用的InnoDB.
遇到死锁的处理方式

mysql -uxxx -pxxx -h服务器ip --port=服务器端口;（如果服务器设置了ip和端口访问的话，一定要带ip和端口）

mysql> show processlist; #查看正在执行的sql （show full processlist;查看全部sql）
mysql> kill id #杀死sql进程；
如果进程太多找不到，就重启mysql吧
/ect/init.d/mysql restart 
或/ect/init.d/mysql stop（如果关不掉就直接kill -9 进程id）  再/ect/init.d/mysql start 
去看看mysql日志文件是否保存死锁日志：
常用目录：/var/log/mysqld.log；（该目录还有其它相关日志文件就都看看）
怎么解决还是要看具体什么问题.


+++++++++++mysql_pconnect用法和mysql_connect类似： +++++++++++
复制代码 代码如下:

<?php 
$conn = mysql_pconnect($host,$user,$pwd); 
mysql_select_db($dbname,$conn); 
$result=mysql_query("select * from table_name where col_id ='test_id'", $conn); 
$result_detail=mysql_fetch_array($result); 
$item = $result_detail['col_id']; 
?> 


备注：作为高并发处理数据库请求时，使用mysql_pconnect并不是一个很好的选择，此时可以考虑缓存及分步式等问题。

PHP持久连接mysql_pconnect()函数可以提高效率比拼JSP 

函数用法： 

复制代码 代码如下:

$dbHost = "localhost"; 
$dbUser = "root"; 
$dbPwd = ""; 
$dbName = "zhoutang"; 
$strSQL = "update tblUser set UserLC=UserLC+1 where UserID=100"; 
$link = mysql_connect($dbHost, $dbUser, $dbPwd) or die('Could not connect: ' .mysql_error()); 
mysql_select_db($dbName); 
mysql_query($strSQL); 
mysql_close($link); 


用法和mysql_connect ()类似，只是有两个区别：

第一， mysql_pconnect（）会先尝试寻找一个在同一个主机上用同样的用户名和密码已经打开的持久连接，如果找到，刚返回此链接的连接标识符而不打开新连接；

第二，当函数执行后，SQL服务器的连接不会被关闭，此连接将保持打开以备以后使用。 

mysql_pconnect（）函数可以大大的提高MYSQL效率，不过，此连接不自动关闭，也会造成一些问题，请注意将不用的连接即时关闭，以避免不必要的错误发生。 

其实，我以前写过PHP持久连接数据库的函数mysql_pconnect(),只是没有做任何的测试，今天做了一个小小的测试，果然真的不错，尤其是连接远程数据库的时候，效果更是非常的明显。 

下面再写一下PHP持久连接数据库存函数的应用方法（一个简单的不能再简单的MYSQL类） 

复制代码 代码如下:

<?php 
class mysql{ 
private $host; 
private $user; 
private $pw; 
private $dbname; 
private $code; 
public function __construct($host,$user,$pw,$dbname,$code){ 
$this->host=$host; 
$this->user=$user; 
$this->pw=$pw; 
$this->dbname=$dbname; 
$this->code=$code; 
$this->conn(); 
} 
public function conn(){ 
$conn=mysql_pconnect($this->host,$this->user,$this->pw) or die("links error");//持久连接 
mysql_select_db($this->dbname,$conn); 
mysql_query("SET NAMES {$this->code}"); 
} 
public function query($sql){ 
$result=mysql_query($sql); 
return $result; 
} 
} 
?> 


+++++++++MySQL CAST与CONVERT 函数的用法+++++++++++
MySQL 的CAST()和CONVERT()函数可用来获取一个类型的值，
并产生另一个类型的值。两者具体的语法如下：
CAST(value as type);
CONVERT(value, type);

++++++SQL笔试题：公司员工与部门查询++++++++++++
建表：
DEPARTMENTS:
DEPARTMENT_ID(primary key),
DEPARTMENT_NAME,
LOCATION
EMPLOYEES:
EMPLOYEE_ID(primary key),
EMPLOYEE_NAME,
EMPLOYEE_JOB,
MANAGER,
SALARY,
DEPARTMENT_ID
列出EMPLOYEES表中各部门的部门号，最高工资，最低工资
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID from EMPLOYEES group by DEPARTMENT_ID;
列出EMPLOYEES表中各部门EMPLOYEE_JOB为'CLERK'的员工的最低工资，最高工资
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID as 部门号 from EMPLOYEES where EMPLOYEE_JOB = 'CLERK' group by DEPARTMENT_ID;
对于EMPLOYEES中最低工资小于1000的部门，列出EMPLOYEE_JOB为'CLERK'的员工的部门号，最低工资，最高工资
view sourceprint?
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID as 部门号 from EMPLOYEES as b
where EMPLOYEE_JOB ='CLERK' and 1000>(select min(SALARY) from EMPLOYEES as a where a.DEPARTMENT_ID = b.DEPARTMENT_ID) group by b.DEPARTMENT_ID
根据部门号由高而低，工资有低而高列出每个员工的姓名，部门号，工资
select DEPARTMENT_ID as 部门号,EMPLOYEE_NAME as 姓名,SALARY as 工资 from EMPLOYEES order by DEPARTMENT_ID desc,SALARY asc
写出对上题的另一解决方法
还没想到，如果你又答案，请联系www.nowamagic.net，我的联系方式在网站首页。
列出'张三'所在部门中每个员工的姓名与部门号
select EMPLOYEE_NAME,DEPARTMENT_ID from EMPLOYEES where DEPARTMENT_ID = (select DEPARTMENT_ID from EMPLOYEES where EMPLOYEE_NAME = '张三')
列出每个员工的姓名，工作，部门号，部门名
select EMPLOYEE_NAME,EMPLOYEE_JOB,EMPLOYEES.DEPARTMENT_ID,DEPARTMENTS.DEPARTMENT_NAME from EMPLOYEES,DEPARTMENTS where EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
列出EMPLOYEES中工作为'CLERK'的员工的姓名，工作，部门号，部门名
select EMPLOYEE_NAME,EMPLOYEE_JOB,DEPARTMENTS.DEPARTMENT_ID,DEPARTMENT_NAME from EMPLOYEES,DEPARTMENTS where DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID and DEPARTMENT_JOB = 'CLERK'
对于EMPLOYEES中有管理者的员工，列出姓名，管理者姓名（管理者外键为MANAGER）
select a.EMPLOYEE_NAME as 姓名,b.EMPLOYEE_NAME as 管理者 from EMPLOYEES as a,EMPLOYEES as b where a.MANAGER is not null and a.MANAGER = b.EMPLOYEE_ID
对于DEPARTMENTS表中，列出所有部门名，部门号，同时列出各部门工作为'CLERK'的员工名与工作
select DEPARTMENT_NAME as 部门名,DEPARTMENTS.DEPARTMENT_ID as 部门号,EMPLOYEE_NAME as 员工名,EMPLOYEE_JOB as 工作 from DEPARTMENTS,EMPLOYEES
where DEPARTMENTS.DEPARTMENT_ID *= EMPLOYEES.DEPARTMENT_ID and EMPLOYEE_JOB = 'CLERK'
对于工资高于本部门平均水平的员工，列出部门号，姓名，工资，按部门号排序
select a.DEPARTMENT_ID as 部门号,a.EMPLOYEE_NAME as 姓名,a.SALARY as 工资 from EMPLOYEES as a
where a.SALARY>(select avg(SALARY) from EMPLOYEES as b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) order by a.DEPARTMENT_ID
对于EMPLOYEES，列出各个部门中平均工资高于本部门平均水平的员工数和部门号，按部门号排序
select count(a.SALARY) as 员工数,a.DEPARTMENT_ID as 部门号 from EMPLOYEES as a
where a.SALARY>(select avg(SALARY) from EMPLOYEES as b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) group by a.DEPARTMENT_ID order by a.DEPARTMENT_ID
对于EMPLOYEES中工资高于本部门平均水平，人数多与1人的，列出部门号，人数，按部门号排序
select count(a.EMPLOYEE_ID) as 员工数,a.DEPARTMENT_ID as 部门号,avg(SALARY) as 平均工资 from EMPLOYEES as a
where (select count(c.EMPLOYEE_ID) from EMPLOYEES as c where c.DEPARTMENT_ID = a.DEPARTMENT_ID and c.SALARY>(select avg(SALARY) from EMPLOYEES as b where c.DEPARTMENT_ID = b.DEPARTMENT_ID))>1
group by a.DEPARTMENT_ID order by a.DEPARTMENT_ID
对于EMPLOYEES中低于自己工资至少5人的员工，列出其部门号，姓名，工资，以及工资少于自己的人数
view sourceprint?
select a.DEPARTMENT_ID,a.EMPLOYEE_NAME,a.SALARY,(select count(b.EMPLOYEE_NAME) from EMPLOYEES as b where b.SALARY < a.SALARY) as 人数 from EMPLOYEES as a
where (select count(b.EMPLOYEE_NAME) from EMPLOYEES as b where b.SALARY<a.SALARY)>5

++++++取出数据库后10条数据++++++++
一种方法是数据库记录倒序排序，然后用limit 10子句获取10条。
 SELECT title AS TITLE FROM news ORDER BY id DESC LIMIT 10;
也可以取得最大记录的id，然后在WHERE子句减去10。
SELECT temp.title as 标题 FROM news AS temp WHERE news_id > (SELECT MAX(id) FROM news) - 10;


+++++++mysql_real_escape_string() 函数+++++++++++
mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。
保护数据库的安全――对即将运行于数据库的SQL语句进行安全性预处理.

常见数据库端口号 
MySQL: 3306
SQL Server: 1433
Oracle: 1521

常见协议端口号 
HTTP: 80
FTP: 20用于数据连接, 21用于端口连接
SSH: 22
Telnet: 23
HTTPS: 443

使用心得：
SQL语句用双引号，其中的值都用单引号，例如"INSERT INTO gril SET money='{$iMaxMoney}',age='18′"
用mysqli扩展代替mysql扩展
用mysqli_real_escape_string和mysqli_escape_string处理传出sql语句中的变量
用mysqli_set_charset(mysqli->set_charset)代替 query "SET NAMES"
联合查询(JOIN)之前，考虑下各个表的数据量，不合适的话应该分开查，尤其是有缓存可用的时候
很多地方需要记录发生时间，但不是每一个表都需要，同样，不是每一个表都需要一个自增量作主键
很多时候为integer类型加上unsigned是很好的
INERT DELEYED、INSERT IGNORE、SELECT DISTINCT…这种语句通常有意想不到的好效果
varchar类型并不是不能超过255长度，而是超过了255，这个字段就不能建立索引了，所以，看你的实际需要了


使用ip2long() 和long2ip()函数来把IP地址转化成整型存储到数据库里。
这种方法把存储空间降到了接近四分之一(char(15)的15个字节对整形的4个字节)，
计算一个特定的地址是不是在一个区段内页更简单了， 而且加快了搜索和排序的速度
(虽然有时仅仅是快了一点)。


+++++++++Mysql如何导入大SQL数据文件++++++
1、修改配置文件：一般默认配置是：1048576/1024/1024 = 1M
windows中修改my.ini文件，在linux中修改my.cnf文件.
C:\Documents and Settings\All Users\Application Data\MySQL\MySQL Server 5.5\my.ini(安装mysql时的,指定的数据文件目录)
修改max_allowed_packet值:
max_allowed_packet=500M;//根据情况选择
修改配置文件后,重启mysql
重启mysql后,在查看修改后的max_allowed_packet值
2、指定字符集编码：登录时指定字符集编码
mysql -uroot -P3308 -p123456 - -default-character-set=utf8 (-P是指指定端口号)
3、导入sql：最后通过source命令，即可成功导入:
source  E:ydj\test.sql


+++++++9个MySQL面试题++++++
1、如何确定 MySQL 是否处于运行状态？
Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status。
然后看看输出即可。
2、如何开启或停止 MySQL 服务？
运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务。
3、如何通过 Shell 登入 MySQL？
运行命令 mysql -u root -p
4、如何列出所有数据库？
运行命令 show databases;
5、如何切换到某个数据库并在上面工作？
运行命令 use database_name; 键入名为 database_name 的数据库。
6、如何列出某个数据库内所有表？
在当前数据库运行命令 show tables;
7、如何获取表内所有 Field 对象的名称和类型？
运行命令 describe table_name;
8、如何删除表？
运行命令 drop table table_name;
9、如何删除数据库？
运行命令 drop database database-name;
10、如何修改Root密码？
修改root密码对于某些特定设置是必不可少的，修改命令如下：
// 使用mysqladmin的password命令来修改（4.1格式）
$mysqladmin -u root password [新口令]
// 旧的修改口令的方法
$mysqladmin -u root -p [旧口令] 新口令 [敲回车后输入新口令，然后回车]
// 使用mysql的命令
$mysql -u root -p
mysql> use mysql;
mysql> update user set password=新口令 where User = ‘用户名’;
mysql> flush privileges;
mysql> quit


++++MYSQL数据库查询当天的信息(以ks_action_log表为例，时间字段是create_time,值是时间戳格式)++++++
select * from `ks_action_log` where date_format(from_UNIXTIME(`create_time`),'%Y-%m-%d') = date_format(now(),'%Y-%m-%d')
或者是：
select * from `ks_action_log` where to_days(date_format(from_UNIXTIME(`create_time`),'%Y-%m-%d')) = to_days(now())
如果该表里面的时间字段类型是DATETIME或TIMESTAMP,可以用一下几个sql语句：
select * from ks_action where to_days(`create_time`) = to_days(now());//查询今天
select * from `article` where to_days(now()) C to_days(`add_time`) <= 1; //查询昨天
select * from `article` where date_sub(curdate(), INTERVAL 7 DAY) <= date(`add_time`);//查询近7天
select * from `article` where date_format(`add_time`, ‘%Y%m') = date_format(curdate() , ‘%Y%m'); //查询本月
select * from `article` where period_diff(date_format(now() , ‘%Y%m') , date_format(`add_time`, ‘%Y%m')) =1; // 查询上一个月
对上面几个针对datetime类型的sql语句分析:
（1）to_days() 它是将具体的某一个日期或时间字符串转换到某一天所对应的unix时间戳。但是，
转换之后的数增加了1，这个粒度的查询是比较粗糙的，有时可能不能满足我们的查询要求，那么就需要使用细粒度的查询方法str_to_date函数了，下面将分析这个函数的用法。
（2）str_to_date()可以把字符串时间完全的翻译过来。
mysql> select str_to_date("2010-11-23 14:39:51",'%Y-%m-%d %H:%i:%s');
+--------------------------------------------------------+
| str_to_date("2010-11-23 14:39:51",'%Y-%m-%d %H:%i:%s') |
+--------------------------------------------------------+
| 2010-11-23 14:39:51                                    |
+--------------------------------------------------------+
具体案例：
select str_to_date(article.`add_time`,'%Y-%m-%d %H:%i:%s')
from article
where str_to_date(article.`add_time`,'%Y-%m-%d %H:%i:%s')>='2012-06-28 08:00:00' and str_to_date(article.`add_time`,'%Y-%m-%d %H:%i:%s')<='2012-06-28 09:59:59';


++++++学会设置MySQL数据库的五个常用参数++++++
(一)连接
连接通常来自Web服务器，下面列出了一些与连接有关的参数，以及该如何设置它们。
1、max_connections
这是Web服务器允许的最大连接数，记住每个连接都要使用会话内存(关于会话内存，文章后面有涉及)。
2、max_packet_allowed
最大数据包大小，通常等于你需要在一个大块中返回的最大数据集的大小，如果你在使用远程mysqldump，那它的值需要更大。
3、aborted_connects
检查系统状态的计数器，确定其没有增长，如果数量增长说明客户端连接时遇到了错误。
4、thread_cache_size
入站连接会在MySQL中创建一个新的线程，因为MySQL中打开和关闭连接都很廉价，速度也快，
它就没有象其它数据库，如Oracle那么多持续连接了，但线程预先创建并不会节约时间，
这就是为什么要MySQL线程缓存的原因了。
(二)查询缓存
MySQL中的缓存查询包括两个解析查询计划，以及返回的数据集，如果基础表数据或结构有变化，将会使查询缓存中的项目无效。
1、query_cache_min_res_unit
MySQL参数中query_cache_min_res_unit查询缓存中的块是以这个大小进行分配的，使用下面的公式计算查询缓存的平均大小，
根据计算结果设置这个变量，MySQL就会更有效地使用查询缓存，缓存更多的查询，减少内存的浪费。
2、query_cache_size
这个参数设置查询缓存的总大小。
3、query_cache_limit
这个参数告诉MySQL丢掉大于这个大小的查询，一般大型查询还是比较少见的，如运行一个批处理执行一个大型报表的统计，因此那些大型结果集不应该填满查询缓存。
qcache hit ratio = qcache_hits / (qcache_hits + com_select)
使用
SQL> show status like 'qcache%';
SQL> show status like 'com_%';
找到这些变量。
average query size = (query_cache_size - qcache_free_memory)/qcache_queries_in_cache
使用
SQL> show variables like 'query%';
qcache_* status variables you can get with:
SQL> show status like 'qcache%';
获取query_cache_size的值。
(三)临时表
内存速度是相当快的，因此我们希望所有的排序操作都在内存中进行，我们可以通过调整查询让结果集更小以实现内存排序，或将变量设置得更大。
tmp_table_size
max_heap_table_size
无论何时在MySQL中创建临时表，它都会使用这两个变量的最小值作为临界值，除了在磁盘上构建临时表外，还会创建许多会话，
这些会话会抢占有限制的资源，因此最好是调整查询而不是将这些参数设置得更高，同时，需要注意的是有BLOB或TEXT字段类型
的表将直接写入磁盘。 深入浅出MySQL双向复制技术
(四)会话内存
MySQL中每个会话都有其自己的内存，这个内存就是分配给SQL查询的内存，因此你想让它变得尽可能大以满足需要。但你不得不
平衡同一时间数据库内一致性会话的数量。这里显得有点黑色艺术的是MySQL是按需分配缓存的，因此，你不能只添加它们并乘以
会话的数量，这样估算下来比MySQL典型的使用要大得多。最佳做法是启动MySQL，连接所有会话，然后继续关注顶级会话的VIRT列，
mysqld行的数目通常保持相对稳定，这就是实际的内存总用量，减去所有的静态MySQL内存区域，就得到了实际的所有会话内存，然后除以会话的数量就得到平均值
1、read_buffer_size
缓存连续扫描的块，这个缓存是跨存储引擎的，不只是MyISAM表。
2、sort_buffer_size
执行排序缓存区的大小，最好将其设置为1M-2M，然后在会话中设置，为一个特定的查询设置更高的值。
3、join_buffer_size
执行联合查询分配的缓存区大小，将其设置为1M-2M大小，然后在每个会话中再单独按需设置。
4、read_rnd_buffer_size
用于排序和order by操作，最好将其设置为1M，然后在会话中可以将其作为一个会话变量设置为更大的值。
(五)慢速查询日志
慢速查询日志是MySQL很有用的一个特性。
1、log_slow_queries
MySQL参数中log_slow_queries参数在my.cnf文件中设置它，将其设置为on，默认情况下，MySQL会将文件放到数据目录，
文件以“主机名-slow.log”的形式命名，但你在设置这个选项的时候也可以为其指定一个名字。
2、long_query_time
默认值是10秒，你可以动态设置它，值从1到将其设置为on，如果数据库启动了，默认情况下，日志将关闭。截至5.1.21和
安装了Google补丁的版本，这个选项可以以微秒设置，这是一个了不起的功能，因为一旦你消除了所有查询时间超过1秒的
查询，说明调整非常成功，这样可以帮助你在问题变大之前消除问题SQL。
3、log_queries_not_using_indexes
开启这个选项是个不错的主意，它真实地记录了返回所有行的查询。
如果在增长请密切注意创建的线程，让你的线程缓存更大，对于2550或100的thread_cache_size，内存占用也不多。

+++++用rand()来实现随机查找+++++
在表tt_dvjobs中随机查询10条数据：
select * from `tt_dvjobs` ORDER BY rand() LIMIT 0 , 10;
实践证明改函数会导致查询性能非常低下，请慎用此函数！


++++MySQL btree索引与hash索引方式的区别+++++
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，
最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。但是现实中都很少用 Hash 索引，
用 B-Tree 索引比hash索引多得多。可以这样理解，BTREE索引是一种B树结构索引，里面的数据根据大小或者其它原因进行了各种编排，
查询时将数据与里面各节点的数据进行对比以快速找到目标。而hash索引是一种集合索引，它对要查询的数据都已经进行了hash处理，
并且把处理的结果与存储的位置对应了起来，这样当你查询某一个值时，它能根据这个值计算出一个与存储位置相关的结果，
从而实现快速命中目标。所以既然如此hash在命中高的同时也有很重要的劣势。
1、Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询，也不能使用匹配%，搜索查询，也不能进行排序操作
由于Hash索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，对于像where id>5或者where title like '%abc%'之类
的查询无能为力。而也正因为这样，对hash索引也不能进行排序。而这些都是很多数据读取操作中经常要使用的功能，所以多数索引仍会使用B-TREE索引。
2、联合索引里无法使用Hash索引
对于联合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，
所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
3、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
对于数据重复性比较高的列，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。
比如对用户的学历、职称、性别进行索引，这些字段值比较固定，hash索引时要定位某一条记录时就会非常麻烦，
会浪费多次表数据的访问，而造成整体性能低下。hash表更适合于唯一性高但又不要求进行排序或者取范围时用的索引，
这点让我想起来REDIS里的hash结构，你扔给他一个hash，键名为用户名，键值为用户的数据json结构，这个就非常适合
使用hash,因为hash会大大提高命中，所以REDIS里能有这么快的速度。
我看到网上有上有很多被转载的文件上都写有一点：Hash 索引在任何时候都不能避免表扫描（Hash 索引是将索引键通过
 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 
值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据
进行相应的比较，并得到相应的结果）。我觉得HASH之所以快就是采用了hash值去查找数据的方式，即便它进行所谓的“表扫描”，
也是一很优化的表扫描，不然hash的查询效率如何远高于B-TREE索引。



++++防止人为误操作MySQL数据库解决方法++++++
1、mysql帮助说明
1. [oldboy_c64 ~]# mysql --help|grep dummy
2.  -U, --i-am-a-dummy Synonym for option --safe-updates, -U.
3. i-am-a-dummy      FALSE
在mysql命令加上选项-U后，当发出没有WHERE或LIMIT关键字的UPDATE或DELETE时，mysql程序就会拒绝执行
2、指定-U登录测试
1. [oldboy_c64 ~]# mysql -uroot -poldboy123 -S /data/3306/mysql.sock -U
2. Welcome to the MySQL monitor. Commands end with ; or \g.
3. Your MySQL connection id is 14
4. Server version: 5.5.32-log MySQL Community Server (GPL)
5. Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
6. Oracle is a registered trademark of Oracle Corporation and/or its
7. affiliates. Other names may be trademarks of their respective
8. owners.
9. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
10. mysql> delete from oldboy.student;
11. ERROR 1175 (HY000): You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column
12. mysql> quit
13. Bye
提示：不加条件无法删除，目的达到。
3、做成别名防止老大和DBA误操作
1. [oldboy_c64 ~]# alias mysql='mysql -U'
2. [oldboy_c64 ~]# mysql -uroot -poldboy123 -S /data/3306/mysql.sock
3. Welcome to the MySQL monitor. Commands end with ; or \g.
4. Your MySQL connection id is 15
5. Server version: 5.5.32-log MySQL Community Server (GPL)
6. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
7. mysql> delete from oldboy.student;
8. ERROR 1175 (HY000): You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column
9. mysql> delete from oldboy.student where Sno=5;
10. Query OK, 1 row affected (0.02 sec)
11. mysql> quit
12. Bye
13. [oldboy_c64 ~]# echo "alias mysql='mysql -U'" >>/etc/profile
14. [oldboy_c64 ~]# . /etc/profile
15. [oldboy_c64 ~]# tail -1 /etc/profile
16. alias mysql='mysql -U'
结论：在mysql命令加上选项-U后，当发出没有WHERE或LIMIT关键字的UPDATE或DELETE时，mysql程序拒绝执行。


+++++MySQL设置允许远程登录数据库方法++++++
 开启 MySQL 的远程登陆帐号有两大步：
1、确定服务器上的防火墙没有阻止 3306 端口
 MySQL 默认的端口是 3306 ，需要确定防火墙没有阻止 3306 端口，否则远程是无法通过 3306 端口连接到 MySQL 的。
如果您在安装 MySQL 时指定了其他端口，请在防火墙中开启您指定的 MySQL 使用的端口号。
2、增加允许远程连接 MySQL 用户并授权
a.首先以 root 帐户登陆 MySQL
b.创建远程登陆用户并授权
> grant all PRIVILEGES on discuz.* to ted@'123.123.123.123' identified by '123456';
上面的语句表示将 discuz 数据库的所有权限授权给 ted 这个用户，允许 ted 用户在 123.123.123.123 这个 IP 进行远程登陆，并设置 ted 用户的密码为 123456 。
下面逐一分析所有的参数：
all PRIVILEGES 表示赋予所有的权限给指定用户，这里也可以替换为赋予某一具体的权限，例 如：select,insert,update,delete,create,drop 等，具体权限间用“,”半角逗号分隔。
discuz.* 表示上面的权限是针对于哪个表的，discuz 指的是数据库，后面的 * 表示对于所有的表，
由此可以推理出：对于全部数据库的全部表授权为“*.*”，对于某一数据库的全部表授权为
“数据库名.*”，对于某一数据库的某一表授 权为“数据库名.表名”。
ted 表示你要给哪个用户授权，这个用户可以是存在的用户，也可以是不存在的用户。
123.123.123.123 表示允许远程连接的 IP 地址，如果想不限制链接的 IP 则设置为“%”即可。
123456 为用户的密码。
执行了上面的语句后，再执行下面的语句，方可立即生效。
> flush privileges;
3.远程登陆MySql数据库
假设ip 为123.123.123.124的主机创建远程登陆用户并授权：
> grant all PRIVILEGES on discuz.* to ted@'123.123.123.123' identified by '123456';
在ip为123.123.123.123的主机上用 cmd打开终端，在终端上输入：
MySql -h123.123.123.124 -uted -p123456  
然后就登陆了ip 为123.123.123.124的数据库。


++++MySQL不同数据库不同数据表导入数据++++++
背景
现在有这么一个需求：
数据库A的user表需要导入到数据库B的account表
user表字段：uid,username,email,password,regdate,salt
account表字段：id,name,email,password,type,salt
导入的字段只有username,email,password,salt，并且regdate需要符合某个条件
下面分几种情况来写sql，主要区分insert into和replace into
情况
导入的数据在B库的表中完全不存在
直接insert into就好，使用replace into效果一样
INSERT INTO `B`.`account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`users`
WHERE regdate>1418313600
导入的数据部分存在
数据部分存在为了区分需要在两个表添加唯一索引，这个唯一索引(UNIQUE)必须是导入的字段里面的值
我在两个表中分别为username和name字段添加唯一索引
直接替换
replace into在操作的时候如果两表数据重复（必须定义UNIQUE），会先删掉那一行（注意是一整行），然后再执行insert into
造成的后果就是，account表中的type字段如果原来有值，会直接删掉，并重新插入，即变成默认值了
REPLACE INTO `B`.`account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`users`
WHERE regdate>1418313600
忽略重复
用IGNORE关键字，如果遇到重复，不会操作当前行
INSERT IGNORE INTO `B`.`account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`users`
WHERE regdate>1418313600
部分更新
比如果只想更新password和salt字段，可以用ON DUPLICATE KEY UPDATE
INSERT INTO `B`.`u_account`(NAME,PASSWORD,email,salt)
SELECT username,PASSWORD,email,salt
FROM `A`.`bbs_ucenter_members`
WHERE regdate>1418313600 ON DUPLICATE KEY UPDATE PASSWORD=VALUES(PASSWORD),salt=VALUES(salt)

++++myisam表转换为innodb表++++++
请确保InnoDB开启，MySQL命令行下SHOW ENGINES命令查看
mysql> ALTER TABLE  boblog_history   ENGINE=InnoDB;
Query OK, 2808 rows affected (0.76 sec)
Records: 2808  Duplicates: 0  Warnings: 0


+++++++MySql存储过程及MySql常用流程控制语法++++++++
/*
该代码是创建了一个名叫"p4"的存储过程并设置了s1,s2,s3两个int型一个varchar型参数，还可以是其他数据类型，内部创建了x1,x2两个变量

DELIMITER是修改分隔符的
DELIMITER $$的意思是把默认分隔符";"换成"$$"，这样分段写的存储过程就能整个被执行，而不是被当成多条sql语句单独执行
创建完过程再将分隔符改回成";"

两种创建变量并赋值的方式
SET @变量名 = 值;
SELECT 值 INTO @变量名;
使用变量前必须先运行该变量赋值语句
过程内部还可以通过 "DECLARE 变量名 类型(字符串型要加范围) DEFAULT 值;" 来创建变量，但如此创建的变量只能在该过程内部访问

存储过程只有三种类型参数 IN,OUT,INOUT
调用过程时过程有几个参数传几个参数，只是IN型的参数可以传的是变量，可以是常量，而OUT和INOUT型的参数传的必须是变量
传给out，inout参数的变量值会随着在过程中改变在外部也改变，而给in参数的变量外部值则不受过程内变量值改变的影响
*/
DELIMITER $$

DROP PROCEDURE IF EXISTS `p4`$$

CREATE PROCEDURE `p4`(IN s1 INT,OUT s2 INT,INOUT s3 VARCHAR(10))
BEGIN
DECLARE x1 VARCHAR(10) DEFAULT 'this is x1'; 
DECLARE x2 VARCHAR(10) DEFAULT 'this is x2'; 
SET s1 = 11;
SET s2 = 22;
SET s3 = 'iss3';

/*
if语法
*/
IF s1 = 11 AND s2 = 12 THEN
SELECT s1,s2;
END IF;

IF s3 = 's3' OR s1 = s2 THEN
SELECT s3;
ELSE 
SELECT s1,s2,s3;
END IF;

/*
case语法
*/
CASE s3
WHEN 's1' THEN
SELECT 'this is s1';
WHEN 's2' THEN
SELECT 'this is s2';
ELSE
SELECT 'this is s3';
END CASE;

/*
while循环
*/
WHILE s1>1 DO
SET s1=s1-1;
END WHILE; 
SELECT s1;

/*
repeat循环语句
与while不同的是while满足条件就执行，repeat始终执行直到满足条件终止
*/
REPEAT  
SET s1 = s1-1; 
UNTIL s1=1  
END REPEAT; 
SELECT s1;


/*
LOOP循环
LOOP没有循环条件，会不停的循环直到遇到 "LEAVE ZiDingYi;" "ZiDingYi"是自定义的LOOP标记
*/
ZiDingYi:LOOP
SET s1 = s1+1;
IF s1 = 5 THEN
LEAVE ZiDingYi;
END IF;
END LOOP;
SELECT s1;


END$$

DELIMITER ;


SET @p_in=1; 
SET @p_out=2;
SET @p_inout = 's3';
SELECT 'Hello World1' INTO @p_4;

/*调用存储过程*/
CALL p4(@p_in,@p_out,@p_inout);
SELECT @p_in,@p_out,@p_inout,@p_4;


/*
存储过程如果只有一个语句则语句不用 begin...end包围
存储过程中可以直接使用外部定义的变量
存储过程中用set和select定义的变量就是全局的，执行该过程后内部用set和select定义的变量外部可以访问，其他过程也可以直接使用
*/
CREATE PROCEDURE p1()   SET @var='p1';  
CREATE PROCEDURE p2() SELECT CONCAT('Last procedure was ',@var);  
CALL p1();  
CALL p2(); 
SELECT @var;

CREATE PROCEDURE p3() SELECT CONCAT(@p3_var,' World');
SET @p3_var='Hello';
CALL p3();

/*删除存储过程*/
DROP PROCEDURE p4;
/*或者*/
DROP PROCEDURE IF EXISTS `p4`

/*查看该数据库下有哪些存储过程 test为数据库名*/
SELECT NAME FROM mysql.proc WHERE db='test';
/*或者*/
SHOW PROCEDURE STATUS WHERE db='test';

/*查看存储过程详细信息，包括创建语句*/
SHOW CREATE PROCEDURE p4;



++++mysql中mysql_fetch_assoc()++++++
mysql_fetch_assoc()从数据库中取出一行（只取一行）作为数组，那么可以用var_dump或者print_r输出,默认为id=1.
$res=mysql_query("select * from ks_zhiding where id>8");
$fff=mysql_fetch_assoc($res);
var_Dump($fff);
结果为：
array (size=3)
  'id' => string '9' (length=1)
  'rank' => string '9' (length=1)
  'name' => string 'aaa' (length=3)


++++mysql临时表+++++
CREATE TEMPORARY TABLE linshi_table (
    `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(20) DEFAULT NULL,
    PRIMARY KEY (`id`)
);
 
INSERT INTO linshi_table(NAME)VALUES('firstName');
UPDATE linshi_table SET NAME='updateName';
SELECT * FROM linshi_table;


DROP TABLE linshi_table;

/*
当前创建的临时表将在当前连接MySQL期间存在。当当前连接断开时，MySQL将自动删除表并释放所用的空间。当然可以在仍然连接的时候删除表并释放空间。
创建临时表很容易，给正常的CREATE TABLE语句加上TEMPORARY关键字
如果在创建名为linshi_table临时表时名为linshi_table的实体表在数据库中已经存在，Mysql临时表将屏蔽（隐藏）非临时表linshi_table
实体表隐藏后不管是查询，插入，更新，都是对临时表进行操作，实体表实际内容不受影响
*/


++order by 多个字段+++
（均未测试）
第一种：order by last_time desc ,id desc
第二种：select id,last_time from yourtablename group by last_time order by last_time desc,id desc


++MySQL搜索关键字所处位置先后排序+++
error_reporting(0);
date_default_timezone_set('PRC');
mysql_connect("localhost","root",'');
mysql_select_db("root");
$re=mysql_query("select * from ks_zhiding where name like '%a%' order by locate('a',name)");
while($rows=mysql_fetch_array($re)){
	echo $rows['name'].'<br>';
}
结果之一可以是：
aaa
change2


+++mysql_fetch_object()+++
实现类似mysql_fetch_array()一样的取数据的功能，但是它会把数据作为对象取出，访问方法可以是$row->to;
while($row=mysql_fetch_object($res)){
	echo $row->id;
}

++++char_length（）与length（）+++++
mysql中字符串长度有两个函数分别为char_length和length，前者可以计算unicode字符，包括中文等字符集的长度，
而length函数用来计算普通字符的长度，他会把一个中文字符的长度计算为2或3.
mysql> select length('的') as l, char_length('的') as cl;
+---+----+
| l | cl |
+---+----+
| 3 |  1 |
+---+----+
可以看到中文“的”的length为3，而char_length函数结果为1

+++sql对结果集进行重新编号+++++
$res=mysql_query("select  ((select count(1) from ks_zhiding where rank < t.rank) +1) as uid, rank,name from ks_zhiding as t where rank < 7 order by name");
while($row=mysql_fetch_array($res)){
    echo $row['uid'].'----'.$row['rank'].'----'.$row['name']."<br>";
}
结果如下：
uid  rank  name
1----1----bob
3----5----change2
2----4----ddd
4----6----gggrr


+++查询连续3天没有登录的人名+++++++
查询连续3天没有登录的人名
select name from table where id=(
select max(id) from table group by to_char(time,'yyyymmdd') having count(*)<3);


++++mysql数据库中字段类型选择+++++
bigint 默认(20)  Max:有符号9223372036854775807  无符号9223372036854775807 * 2
int 默认(11)   Max:有符号2147483647  无符号4294967285
mediumint Max:有符号8388607 无符号：16777215
smallint 默认(6)  Max:有符号32767  无符号65535
tinyint 默认(4)   Max:有符号127  无符号255
varchar (可变长度),1000个汉字/2000英文 ,效率比char低，但是比char省空间 
char (固定长度),少则满，多则溢出 ,效率比varchar高，但是比varchar占空间（以空间换效率）
[VARCHAR虽然比CHAR节省空间，但是如果一个VARCHAR列经常被修改，而且每次被修改的数据的长度不同，这会引起'行迁移'(Row Migration)现象，
而这造成多余的I/O,是数据库设计和调整中要尽力避免的，在这种情况下用CHAR代替VARCHAR会更好一些.]
时间相关：
DATETIME：这个类型能保存1001到9999年，精度为秒，与时区无关，使用8个字节存储，存储格式封装为YYYYMMDDHHMMSS的
整数，因此它是一种可排序的类型，显示时以ANSI标准定义的日期和时间表示方法显示。
TIMESTAMP：它保存了从1970年1月1日午夜以来的秒数，也就是常说的时间戳，它使用4个字节来存储，依赖于时区。
除了特殊情况外，通常我们应该尽量使用TIMESTAMP，因为它比DATETIME更省空间，现实中有些人喜欢
使用int来存储时间戳（包括刚出来工作时的我），这并不会带来任何收益，用整数保存时间戳不方便，
因为取出来之后还需要程序转换下，所以不推荐这样做。
用ENUM还是VARCHAR?
ENUM 类型是非常快和紧凑的。实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，
用这个字段来做一些选项列表变得相当的完美。
如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限
而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。
current_timestamp()获取当前时间戳。

myql中的btree索引与hash索引的区别：
就检索效率而言，hash索引比btree高的多。但是事实上为什么btree的应用更广？
1)hash索引仅仅满足"=""IN""<=>"查询。不能用范围查询；
2）Hash 索引无法被用来避免数据的排序操作；
3）Hash 索引不能利用部分索引键查询；
4）Hash 索引在任何时候都不能避免表扫描；
5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。


memory引擎：
memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。
MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。
　存储在MEMORY数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当作长度固定不变的CHAR类型，所以可以使用。
create table tab_memory engine=memory select id,name,age,addr from man order by id;
+++关系型数据库与非关系型数据库++++
web2.0时代中催生的新需求：
1.对数据库高并发读写的需求；
关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。
例如像JavaEye网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。
2.对海量数据的高效率存储和访问的需求；
以Friendfeed为例，一个月就达到了 2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。
3.对数据库的高可扩展性和高可用性的需求；
对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展 是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？
4.对复杂的sql查询，特别是多表关联查询的需求。
任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询，特别是SNS类型
的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页
查询，SQL的功能被极大的弱化了。



++++mysql常用参数+++++
1. max_connections
//查看mysql允许的最大连接数
$r=mysql_query("show variables like 'max_connections'");
while($row = mysql_fetch_row($r)){
   print_r($row);
}
//输出： Array ( [0] => max_connections [1] => 151 )
//查看当前mysql连接数
$r2=mysql_query("show status like 'max%connections'");
while($row2 = mysql_fetch_row($r2)){
   print_r($row2);
}
//输出：Array ( [0] => Max_used_connections [1] => 1 )
取值参考：
max_used_connections / max_connections * 100% （理想值≈ 85%）  
如果max_used_connections跟max_connections相同 那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大。

2.back_log 
MySQL能暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用。如果MySQL的连接数据
达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待
连接的数量超过 back_log，将不被授予连接资源。 
back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间
内有很多连接，你需要增加它，换句话说，这值对到来的TCP/IP连接的侦听队列的大小。 
当观察你主机进程列表（mysql> show full processlist），发现大量
264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，
就要加大back_log 的值了。 
默认数值是50，可调优为128，对于Linux系统设置范围为小于512的整数。

3.interactive_timeout 
一个交互连接在被服务器在关闭前等待行动的秒数。一个交互的客户被定义为对mysql_real_connect()使用CLIENT_INTERACTIVE 选项的客户。  
默认数值是28800，可调优为7200。

4.key_buffer_size 
key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值 Key_read_requests
和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，
至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。 
key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。
可以使用检查状态值created_tmp_disk_tables得知详情。

5.query_cache_size
使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。 
通过检查状态值Qcache_*，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。
如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，如果Qcache_hits的值也 非常大，则表明查询缓冲
使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲
反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲。 
与查询缓冲有关的参数还有query_cache_type、query_cache_limit、query_cache_min_res_unit。 
query_cache_type指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。 
query_cache_limit指定单个查询能够使用的缓冲区大小，缺省为1M。 
query_cache_min_res_unit是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。
检查状态值 Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小 query_cache_min_res_unit。

6.record_buffer_size
每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。
默认数值是131072(128K)，可改为16773120 (16M)

7.read_rnd_buffer_size
随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先
扫描一遍该缓冲，以避 免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接
发放该缓冲空间，所以应尽量适当设置该值，以避免内存开 销过大。 一般可设置为16M.

8.sort_buffer_size
每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。默认数值是2097144(2M)，可改为16777208 (16M)。

9.join_buffer_size
联合查询操作所能使用的缓冲区大小
record_buffer_size，read_rnd_buffer_size，sort_buffer_size，join_buffer_size为每个线程独占，也就是说，
如果有100个线程连接，则占用为16M*100

10.table_cache
表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问
表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你
发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了
（上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。
如果设置得太高，可能会造成文件描述符不足，从而造成性能 不稳定或者连接失败。1G内存机器，推荐值是128－256。
内存在4GB左右的服务器该参数可设置为256M或384M。

11.max_heap_table_size
用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变，
即set @max_heap_table_size=# 这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表
大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。

12.tmp_table_size
通过设置tmp_table_size选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时
将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，
避免临时表过大导致生成基于硬盘的MyISAM表。
每次创建临时表，Created_tmp_tables增加，如果临时表大小超过tmp_table_size，则是在磁盘上创建临时 表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配 置是：
Created_tmp_disk_tables / Created_tmp_tables * 100% <= 25%比如上面的服务器Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%，应该相当好了
默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞.

13.thread_cache_size
可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。
如果有很多新的线程，为了提高性能可以这个变量值。通过比较 Connections和Threads_created状态的变量，可以看到这个
变量的作用。
默认值为110，可调优为80。 

14.thread_concurrency
推荐设置为服务器 CPU核数的2倍，例如双核的CPU, 那么thread_concurrency的应该为4；2个双核的cpu, thread_concurrency的值应为8。默认为8

15.wait_timeout
指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。

配置InnoDB引擎的几个变量
innodb_buffer_pool_size
对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。
innodb_flush_log_at_trx_commit
主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的 ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。 实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。
innodb_log_buffer_size
log缓存大小，一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。
innodb_additional_mem_pool_size
该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。
innodb_thread_concurrency=8
推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8。

innodb引擎优化
innodb_buffer_pool_size     （面试必问）
主要存放热数据，按照page来存放，page为最小单位，甚至是按段来存放
建议值： 如果是专用数据库server 建议分到物理内存的50% -- 75% 
 
如果跑有其他服务，那么建议“2/8的原则”：
比如100G的数据，最少达到10%的活跃数据，那么建议buffer pool分20G
如果是好友关系系统，这样的数据都几乎是热数据，那么建议30%-50%的内存
再比如偷菜游戏，几乎所有都能达到90%的热数据，那么你懂的
 
innodb_buffer_pool_instances        
主要为了方便buffer pool全局的锁，
一般情况下设置为8 ，在5.5版本是分到4 ，到了5.6版本之后要分到8，不能改成其他值，因为这是压测得出的结果，8是可能得到最好的性能
 
innodb_log_file_size                
建议设置为data page的百分比，比如page为15% 那么buffer pool为100G ，那么两边相乘得出结果为15G，其实建议的是与data page配置的相等，有可能都配置不了那么大，那么就将file_size设置为1g
 
那么如果我们要用多个log file，就会涉及到以下参数 ：
innodb_log_file_in_gourp
可以设置有几个log文件，至于如何计算：
Innodb的redo log           文件大小，总大小为innodb_log_file_size *
Innodb_log_file_ingroup     总大小不要低于600M
 
一般建议3个log file即可 多了没有必要
 
 
本文来自道森学习笔记，版权归 http://wubx.net/ 所有
innodb_file_per_table          
是否设置独立表空间
在5.6之前是关闭的， 在5.6之后默认为打开，建议是打开状态
 
innodb_file_format     #建议指定为 Barracuda
                                                       
 
innodb_flush_log_at_trx_commit
如果在导数据，可能是2天或者3天也没有导完，那么可能是这个参数设置为1的结果导致
1  为每一次事务进一次刷新到磁盘，安全度高，但是性能最低，经常会导致导数据最慢
0  每秒钟进一下事务的刷新到磁盘
2  一般建议值，大约每秒一次事务的刷新及同步到磁盘，实际只写到操作系统的buffer中，操作系统如果断电会导致失误丢失；#因为导数据都是人为参与的过程所以设置为2，让速度最大化完成，如果出错再手动搞一次即可，建议值
 
innodb_flush_log_at_timeout  (在5.6中被引入）
・该参数用于控制每N秒（1-2700秒之间）刷新一次日志。是对group commit的一个增强功能，默认是1秒，1秒钟刷新一次并由croup commit来处理，实际可以在1-2700秒之间来搞，如果系统对性能要求很高，可以将这个值设置大一些，吞吐率也会更高，因为group commit工作也会更好一点，如果说对同步实时性要求很高，那么就设置低一点，默认值即可
之间是一个相对的关系，如果调大会得到一个很好的性能，但是从库可能会出现延迟
如果调整为3秒，那么这3秒做一次commit，那么在第2秒的时候挂掉了，那么在这2秒的时候数据会丢失
 
 
innodb_flush_method
用指定数据实际写到磁盘上的方法，直接使用O_DIRECT即可
O_DIRECT 工作在XFS或EXT4上性能都很不错的
最大问题就是O_DIRECT用来减小系统的VFS级别的cache，节省出来的内存可以提供buffer pool来使用
如果用fsync来做，其会占用vfs级别的cache，会占用大量内存，如果buffer pool很大，那么容易造成oom
所以使用O_DIRECT来做是为了节省内存提供buffer pool更大空间
 
innodb_flush_neighbors
默认是0 在用这个参数之后会临近extent脏页面进行刷新
比如在进行写入的时间，会将脏也进行check ，这个时间会将脏页面合并成顺序写 就是说将临近的extent也合并进去
再比如第一个extent和第二个extent 是挨着的，那么移到这里之后发现第二个也有，那么顺便将第二个也刷过去
如果是sas sata 盘建议使用1；但是对于ssd是没有寻址延迟，所以不需要脏页面刷新，因为原先就是热数据但是刷新之后又变为冷数据数据又会做一次加载.

IO相关优化
innodb_io_capacity   #重要
该参数为innodb io最大数 
一般来说10W iops很正常，后期进行了优化： hdd 150 * 磁盘数 ， ssd 2000-1万 
比如 6块盘做了RAID10 那么这样计算的话是 150*3
需要考虑的是6块盘做的RAID 需要考虑多少快盘的IO能力 ；再考虑如果先做RAID 1能否提升IO能力，如果不能提升那么无非是0可以提升IO能力，所以是6块盘的RAID10 只能获得3块盘的IO能力

以下是对capactiy的补充参数
比如这里配置的是3块盘的450个，但是峰值会更高，可能会达到1000个或更多，那么可以对以下参数指定最大值
 
innodb_io_capacity_max              #设置io_capacity 最大值 


++++++++
在MySQL数据库中，用的最多的字符型数据类型就是Varchar和Char，这两种数据类型虽然都是用来存放字符型数据，但是
无论从结构还是从数据的保存方式来看，两者相差很大。而且其具体的实现方式，还依赖与存储引擎。我这里就以大家最常用
的MYISAM存储引擎为例，谈谈这两种数据类型的差异。在后续建议中，也是针对这种存储类型而言的。
Varchar往往用来保存可变长度的字符串。简单的说，我们只是给其固定了一个最大值，然后系统会根据实际存储的数据量来
分配合适的存储空间。为此相比CHAR字符数据而言，其能够比固定长度类型占用更少的存储空间。通常情况下，VARCHAR数据
类型能够节约磁盘空间，为此往往认为其能够提升数据库的性能。不过这里需要注意的是，这往往是一把双刃剑。其在提升
性能的 同时，往往也会产生一些副作用。如因为其长度是可变的，为此在数据进行更新时可能会导致一些额外的工作。如在
更改前，其字符长度是10位(Varchar 规定的最长字符数假设是50位)，此时系统就只给其分配10个存储的位置(假设不考虑
系统自身的开销)。更改后，其数据量达到了20位。由于没有超过最大 50位的限制，为此数据库还是允许其存储的。只是
其原先的存储位置已经无法满足其存储的需求。此时系统就需要进行额外的操作。如根据存储引擎不同，有的会 采用拆分
机制，而有的则会采用分页机制。
CHAR数据类型与VARCHAR数据类型不同，其采用的是固定长度的存储方式。简单的说，就是系统总为其分配最大的存储空间。
当数据保存时，即使 其没有达到最大的长度，系统也会为其分配这么多的存储空间。显然，这种存储方式会造成磁盘空间的
浪费。这里笔者需要提醒的一点是，当字符位数不足时，系统 并不会采用空格来填充。相反，如果在保存CHAR值的时候，
如果其后面有空值，系统还会自动过滤其空格。而在进行数据比较时，系统又会将空格填充到字符串 的末尾。
显然，VARCHAR与CHAR两种字符型数据类型相比，最大的差异就是前者是可变长度，而后者则是固定长度。在存储时，
前者会根据实际存储的数据 来分配最终的存储空间。而后者则不管实际存储数据的长度，都是根据CHAR规定的长度来
分配存储空间。这是否意味着CHAR的数据类型劣于VARCHAR 呢?其实不然。否则的话，就没有必要存在CHAR字符类型了。
虽然VARCHAR数据类型可以节省存储空间，提高数据处理的效率。但是其可变长度带来的一 些负面效应，有时候会抵消
其带来的优势。为此在某些情况下，还是需要使用Char数据类型。
二、使用建议
!、根据字符的长度来判断，是考虑其长度的是否相近来确定选择char还是varchar，如何字段的长度基本都是一样或者
其长度总是近似的可以选用char
2、是从碎片角度进行考虑
用可变长度的字符型数据时，数据库管理员要时不时的对碎片进行整理。如执行数据库导出导入作业，来消除碎片。
2、即使使用Varchar数据类型，也不能够太过于慷慨！
比如你只使用到90个字符，VARCHAR(100)与VARCHAR(200)真的相同吗?结果是否定的。虽然他们用来存储90个字符的数据，
其存储空间相同。但是对于内存的消耗是不同的.
三、总结char，varchar，text区别
长度的区别，char范围是0～255，varchar最长是64k，但是注意这里的64k是整个row的长度，要考虑到其它的column，
还有如果存在not null的时候也会占用一位，对不同的字符集，有效长度还不一样，比如utf8的，最多21845，还要除去
别的column，但是varchar在一般情况下存储都够用了。如果遇到了大文本，考虑使用text，最大能到4G。
效率来说基本是char>varchar>text，但是如果使用的是Innodb引擎的话，推荐使用varchar代替char;
char和varchar可以有默认值，text不能指定默认值;
数据库选择合适的数据类型存储还是很有必要的，对性能有一定影响。这里在零碎记录两笔，对于int类型的，如果
不需要存取负值，最好加上unsigned；对于经常出现在where语句中的字段，考虑加索引，整形的尤其适合加索引。


+++binary与BLOB+++
binary 和 varbinary
固定长度 (binary) 的或可变长度 (varbinary) 的 binary 数据类型。
binary [ ( n ) ]
固定长度的 n 个字节二进制数据。N 必须从 1 到 8,000。存储空间大小为 n+4 字节。 
BLOB (binary large object)
BLOB (binary large object),二进制大对象，是一个可以存储二进制文件的容器。
在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。
BLOB是一个大文件，典型的BLOB是一张图片或一个声音文件，由于它们的尺寸，必须使用特殊的方式来处理
（例如：上传、下载或者存放到一个数据库）。
大型对象
BLOB就是使用二进制保存数据。
如：保存位图。
CLOB使用CHAR来保存数据。
如：保存XML文档。


+++时间戳与整数++++
MySQL 有个数据类型叫TIMESTAMP，顾名思义，就是时间戳，支持的时间范围是从UTC 1970年元旦凌晨零点到UTC 2038年元月19日三点14分零七秒。毫无疑问，这是个32位的 UNIX 时间戳。
那么你觉得，当 MySQL 在整数和这样的时间戳之间比较时，会发生什么呢？报错？还是把整数转成时间戳？或者把时间戳转成整数？都不是！MySQL 会首先把整数以十进制转成字符串，然后再把字符串转成时间。也就是，20141028000000这么大的整数，会转成字符串，然后按时间的格式理解，变成2014年10月28日凌晨零点。
直接把字符串转成时间没问题。
布尔值
MySQL 有个叫BOOL的类型。可是，它的文档位于数的类型章节之中。而且，它仅仅只是TINYINT(1)的别名！这意味着，MySQL 中的布尔值与整数 0 和 1 是没有分别的。连 Python 都不如，至少 Python 的 bool 是 int 的子类。


+++mysql复制一条数据到另一个表+++
insert into 表1(字段1,字段2,字段3) select 字段1,字段2,字段3 from 表1 where id=1


++mysql中每隔一段时间自动执行一次sql语句+++
mysql要实现定时执行sql语句就要用到Event

具体操作如下：

先看看看event 事件是否开启
show variables like '%sche%';

如没开启，则开启。需要数据库超级权限
set global event_scheduler =1;

创建存储过程 update_a  (注：就是你要执行的sql语句)
mysql> create procedure update_a() update a set a.y_avg=(select avg(b.youhao) from b where a.a_id=b.a_id);

创建一个定时任务：event e_updateA 
mysql> create event if not exists e_updateA
    -> on schedule every 60 second      ---设置60秒执行一次    
      
    -> on schedule at date_add(now(),interval 1 minute) ---在一分钟后执行

    -> on completion preserve
    -> do call update_a();    ---执行update_a()存储过程

创建Event之后，sql语句就定时执行一次。

关闭事件任务
mysql> alter event e_updateA ON
    -> COMPLETION PRESERVE DISABLE;

开启事件任务
mysql> alter event e_updateA ON
    -> COMPLETION PRESERVE ENABLE;


+++mysql临时表及mysql性能优化++++
MySQL在执行SQL查询时可能会用到临时表，一般情况下，用到临时表就意味着性能较低。
sql执行会生成一个巨大的临时表，当内存放不下时，要全部copy 到磁盘，导致IO飙升，时间开销增大。
临时表存储
MySQL临时表分为“内存临时表”和“磁盘临时表”，其中内存临时表使用MySQL的MEMORY存储引擎，磁盘临时表使用MySQL的MyISAM存储引擎；
一般情况下，MySQL会先创建内存临时表，但内存临时表超过配置指定的值后，MySQL会将内存临时表导出到磁盘临时表；
使用临时表的场景
1）ORDER BY子句和GROUP BY子句不同， 例如：ORDERY BY price GROUP BY name；
2）在JOIN查询中，ORDER BY或者GROUP BY使用了不是第一个表的列 例如：SELECT * from TableA, TableB ORDER BY TableA.price GROUP by TableB.name
3）ORDER BY中使用了DISTINCT关键字 ORDERY BY DISTINCT(price)
4）SELECT语句中指定了SQL_SMALL_RESULT关键字 SQL_SMALL_RESULT的意思就是告诉MySQL，结果会很小，请直接使用内存
临时表，不需要使用索引排序 SQL_SMALL_RESULT必须和GROUP BY、DISTINCT或DISTINCTROW一起使用 一般情况下，我们
没有必要使用这个选项，让MySQL服务器选择即可。
使用临时表一般都意味着性能比较低，特别是使用磁盘临时表，性能更慢，因此我们在实际应用中应该尽量避免临时表的使用。 常见的避免临时表的方法有：
1）创建索引：在ORDER BY或者GROUP BY的列上创建索引；
2）分拆很长的列：一般情况下，TEXT、BLOB，大于512字节的字符串，基本上都是为了显示信息，而不会用于查询条件，
 因此表设计的时候，应该将这些列独立到另外一张表。
SQL优化
如果表的设计已经确定，修改比较困难，那么也可以通过优化SQL语句来减少临时表的大小，以提升SQL执行效率。
常见的优化SQL语句方法如下：
1）拆分SQL语句
临时表主要是用于排序和分组，很多业务都是要求排序后再取出详细的分页数据，这种情况下可以将排序和取出详细数据拆分
成不同的SQL，以降低排序或分组时临时表的大小，提升排序和分组的效率，我们的案例就是采用这种方法。
2）优化业务，去掉排序分组等操作
有时候业务其实并不需要排序或分组，仅仅是为了好看或者阅读方便而进行了排序，例如数据导出、数据查询等操作，这种
情况下去掉排序和分组对业务也没有多大影响。
如何判断使用了临时表？
使用explain查看执行计划，Extra列看到Using temporary就意味着使用了临时表。


+++++group by与distinct++++
distinct用法：SELECT DISTINCT Company FROM Orders    //从 Company" 列中仅选取唯一不同的值
加了索引之后 distinct 比没加索引的 distinct 快了 107倍。
加了索引之后 group by 比没加索引的 group by 快了 43倍。
再来对比 ：distinct  和 group by ：
不管是加不加索引 group by 都比 distinct 快。因此使用的时候建议选 group by。