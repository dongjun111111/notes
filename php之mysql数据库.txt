1--》数据库中字段类型的选择：
字符串：utf8_general_ci

2--》InnoDB还是MyISAM，区别有以下几点：
1、首先我目前平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。
2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。
能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
3、从平台角度来说，经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，
这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。
如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为我平台上最小的一个数据库实例的数据量基本都是几十G大小。
4、从我接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的
，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。
5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，
让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。
6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，
虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。
7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，
非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。
当然Innodb也不是绝对不用，用事务的项目如模拟炒股项目，我就是用Innodb的，活跃用户20多万时候，也是很轻松应付了
，因此我个人也是很喜欢Innodb的，只是如果从数据库平台应用出发，我还是会首选MyISAM。

时间与日期格式：
MySQL数据类型	含义
date	        3字节，日期，格式：2014-09-18
time	        3字节，时间，格式：08:42:30
datetime	8字节，日期时间，格式：2014-09-18 08:42:30
timestamp	4字节，自动存储记录修改的时间
year	        1字节，年份
数值数据格式：
整型
MySQL数据类型	含义（有符号）
tinyint	        1字节，范围（-128~127）
smallint	2字节，范围（-32768~32767）
mediumint	3字节，范围（-8388608~8388607）
int	        4字节，范围（-2147483648~2147483647）
bigint	        8字节，范围（+-9.22*10的18次方）


字符串数据类型
MySQL数据类型	含义
char(n)	        固定长度，最多255个字符
varchar(n)      可变长度，最多65535个字符
tinytext        可变长度，最多255个字符
text            可变长度，最多65535个字符
mediumtext	可变长度，最多2的24次方-1个字符
longtext	可变长度，最多2的32次方-1个字符

binary关键字。只用于char和varchar值。当为列指定了该属性时，将以区分大小写的方式排序。与之相反，忽略binary属性时，将使用不区分大小写的方式排序。例如：
复制代码 代码如下:
hostname char(25) binary not null
unsigned关键字。上面定义的都是有符号的，当然了，也可以加上unsigned关键字，定义成无符号的类型，那么对应的取值范围就要翻翻了，比如：
tinyint unsigned的取值范围为0~255。
unique关键字。被赋予unique属性的列将确保所有值都有不同的值，只是null值可以重复。一般会指定一个列为unique，以确保该列的所有值都不同。


+++++++++为了给高并发情况下的MySQL进行更好的优化，有必要了解一下MySQL查询更新时的锁表机制。+++++++++

一、概述
MySQL有三种锁的级别：页级、表级、行级。
MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level
locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。
MySQL这3种锁的特性可大致归纳如下：
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

二、MyISAM表锁
MyISAM存储引擎只支持表锁，是现在用得最多的存储引擎。
但表级锁让多线程可以同时从数据表中读取数据，但是如果另一个线程想要写数据的话，就必须要先取得排他访问。正在更新数据时，必须要等到更新完成了，其他线程才能访问这个表。（这种机制造成了并发读写容易出现表锁争夺而导致阻塞访问）
1、查询表级锁争用情况
可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：
  mysql> show status like 'table%';
  +―――――――C+―――-+
  | Variable_name | Value |
  +―――――――C+―――-+
  | Table_locks_immediate | 76939364 |  （表示可以立即获取锁的次数）
  | Table_locks_waited | 305089 |  （表示不能立即获取锁，需要等待锁的次数;）        
  +―――――――C+―――-+
  2 rows in set (0.00 sec)
  Table_locks_waited/(Table_locks_immediate+Table_locks_waited)
  这个比例值越大说明表级锁争用的情况越严重。
  例：比例值=0.01说明100次进程里就有一次是需要等待锁的进程；

2、MySQL表级锁的锁模式
MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write
Lock）。MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
所以对MyISAM表进行操作，会有以下情况：
a、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。
b、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。

3、并发插入
原则上数据表有一个读锁时，其它进程无法对此表进行更新操作，但在一定条件下，MyISAM表也支持查询和插入操作的并发进行。
MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。
a、当concurrent_insert设置为0时，不允许并发插入。
b、当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
c、当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。
4、MyISAM的锁调度
由于MySQL认为写请求一般比读请求要重要，所以如果有读写请求同时进行的话，MYSQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段中存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞。
我们可以通过一些设置来调节MyISAM的调度行为：
a、通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
b、通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
c、通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。
    上面3种方法都是要么更新优先，要么查询优先的方法。这里要说明的就是，不要盲目的给mysql设置为读优先，因为一些需要长时间运行的查询操作，也会使写进程“饿死”。只有根据你的实际情况，来决定设置哪种操作优先。
    这些方法还是没有从根本上同时解决查询和更新的问题。在一个有大数据量高并发表的mysql里，我们还可采用另一种策略来进行优化，那就是通过mysql主从（读写）分离来实现负载均衡，这样可避免优先哪一种操作从而可能导致另一种操作的堵塞。下面将用一个篇幅来说明mysql的读写分离技术。

MyISAM使用的是 flock 类的函数，直接就是对整个文件进行锁定（叫做文件锁定），InnoDB使用的是 fcntl 类的函数，可以对文件中局部数据进行锁定（叫做行锁定），所以区别就是在这里。
另外MyISAM的数据表是按照单个文件存储的，可以针对单个表文件进行锁定，但是InnoDB是一整个文件，把索引、数据、结构全部保存在 ibdata 文件里，所以必须用行锁定。
死锁
所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中,
因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.
此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.
表级锁不会产生死锁.所以解决死锁主要还是真对于最常用的InnoDB.
遇到死锁的处理方式

mysql -uxxx -pxxx -h服务器ip --port=服务器端口;（如果服务器设置了ip和端口访问的话，一定要带ip和端口）

mysql> show processlist; #查看正在执行的sql （show full processlist;查看全部sql）
mysql> kill id #杀死sql进程；
如果进程太多找不到，就重启mysql吧
/ect/init.d/mysql restart 
或/ect/init.d/mysql stop（如果关不掉就直接kill -9 进程id）  再/ect/init.d/mysql start 
去看看mysql日志文件是否保存死锁日志：
常用目录：/var/log/mysqld.log；（该目录还有其它相关日志文件就都看看）
怎么解决还是要看具体什么问题.


+++++++++++mysql_pconnect用法和mysql_connect类似： +++++++++++
复制代码 代码如下:

<?php 
$conn = mysql_pconnect($host,$user,$pwd); 
mysql_select_db($dbname,$conn); 
$result=mysql_query("select * from table_name where col_id ='test_id'", $conn); 
$result_detail=mysql_fetch_array($result); 
$item = $result_detail['col_id']; 
?> 


备注：作为高并发处理数据库请求时，使用mysql_pconnect并不是一个很好的选择，此时可以考虑缓存及分步式等问题。

PHP持久连接mysql_pconnect()函数可以提高效率比拼JSP 

函数用法： 

复制代码 代码如下:

$dbHost = "localhost"; 
$dbUser = "root"; 
$dbPwd = ""; 
$dbName = "zhoutang"; 
$strSQL = "update tblUser set UserLC=UserLC+1 where UserID=100"; 
$link = mysql_connect($dbHost, $dbUser, $dbPwd) or die('Could not connect: ' .mysql_error()); 
mysql_select_db($dbName); 
mysql_query($strSQL); 
mysql_close($link); 


用法和mysql_connect ()类似，只是有两个区别：

第一， mysql_pconnect（）会先尝试寻找一个在同一个主机上用同样的用户名和密码已经打开的持久连接，如果找到，刚返回此链接的连接标识符而不打开新连接；

第二，当函数执行后，SQL服务器的连接不会被关闭，此连接将保持打开以备以后使用。 

mysql_pconnect（）函数可以大大的提高MYSQL效率，不过，此连接不自动关闭，也会造成一些问题，请注意将不用的连接即时关闭，以避免不必要的错误发生。 

其实，我以前写过PHP持久连接数据库的函数mysql_pconnect(),只是没有做任何的测试，今天做了一个小小的测试，果然真的不错，尤其是连接远程数据库的时候，效果更是非常的明显。 

下面再写一下PHP持久连接数据库存函数的应用方法（一个简单的不能再简单的MYSQL类） 

复制代码 代码如下:

<?php 
class mysql{ 
private $host; 
private $user; 
private $pw; 
private $dbname; 
private $code; 
public function __construct($host,$user,$pw,$dbname,$code){ 
$this->host=$host; 
$this->user=$user; 
$this->pw=$pw; 
$this->dbname=$dbname; 
$this->code=$code; 
$this->conn(); 
} 
public function conn(){ 
$conn=mysql_pconnect($this->host,$this->user,$this->pw) or die("links error");//持久连接 
mysql_select_db($this->dbname,$conn); 
mysql_query("SET NAMES {$this->code}"); 
} 
public function query($sql){ 
$result=mysql_query($sql); 
return $result; 
} 
} 
?> 


+++++++++MySQL CAST与CONVERT 函数的用法+++++++++++
MySQL 的CAST()和CONVERT()函数可用来获取一个类型的值，
并产生另一个类型的值。两者具体的语法如下：
CAST(value as type);
CONVERT(value, type);

++++++SQL笔试题：公司员工与部门查询++++++++++++
建表：
DEPARTMENTS:
DEPARTMENT_ID(primary key),
DEPARTMENT_NAME,
LOCATION
EMPLOYEES:
EMPLOYEE_ID(primary key),
EMPLOYEE_NAME,
EMPLOYEE_JOB,
MANAGER,
SALARY,
DEPARTMENT_ID
列出EMPLOYEES表中各部门的部门号，最高工资，最低工资
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID from EMPLOYEES group by DEPARTMENT_ID;
列出EMPLOYEES表中各部门EMPLOYEE_JOB为'CLERK'的员工的最低工资，最高工资
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID as 部门号 from EMPLOYEES where EMPLOYEE_JOB = 'CLERK' group by DEPARTMENT_ID;
对于EMPLOYEES中最低工资小于1000的部门，列出EMPLOYEE_JOB为'CLERK'的员工的部门号，最低工资，最高工资
view sourceprint?
select max(SALARY) as 最高工资,min(SALARY) as 最低工资,DEPARTMENT_ID as 部门号 from EMPLOYEES as b
where EMPLOYEE_JOB ='CLERK' and 1000>(select min(SALARY) from EMPLOYEES as a where a.DEPARTMENT_ID = b.DEPARTMENT_ID) group by b.DEPARTMENT_ID
根据部门号由高而低，工资有低而高列出每个员工的姓名，部门号，工资
select DEPARTMENT_ID as 部门号,EMPLOYEE_NAME as 姓名,SALARY as 工资 from EMPLOYEES order by DEPARTMENT_ID desc,SALARY asc
写出对上题的另一解决方法
还没想到，如果你又答案，请联系www.nowamagic.net，我的联系方式在网站首页。
列出'张三'所在部门中每个员工的姓名与部门号
select EMPLOYEE_NAME,DEPARTMENT_ID from EMPLOYEES where DEPARTMENT_ID = (select DEPARTMENT_ID from EMPLOYEES where EMPLOYEE_NAME = '张三')
列出每个员工的姓名，工作，部门号，部门名
select EMPLOYEE_NAME,EMPLOYEE_JOB,EMPLOYEES.DEPARTMENT_ID,DEPARTMENTS.DEPARTMENT_NAME from EMPLOYEES,DEPARTMENTS where EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
列出EMPLOYEES中工作为'CLERK'的员工的姓名，工作，部门号，部门名
select EMPLOYEE_NAME,EMPLOYEE_JOB,DEPARTMENTS.DEPARTMENT_ID,DEPARTMENT_NAME from EMPLOYEES,DEPARTMENTS where DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID and DEPARTMENT_JOB = 'CLERK'
对于EMPLOYEES中有管理者的员工，列出姓名，管理者姓名（管理者外键为MANAGER）
select a.EMPLOYEE_NAME as 姓名,b.EMPLOYEE_NAME as 管理者 from EMPLOYEES as a,EMPLOYEES as b where a.MANAGER is not null and a.MANAGER = b.EMPLOYEE_ID
对于DEPARTMENTS表中，列出所有部门名，部门号，同时列出各部门工作为'CLERK'的员工名与工作
select DEPARTMENT_NAME as 部门名,DEPARTMENTS.DEPARTMENT_ID as 部门号,EMPLOYEE_NAME as 员工名,EMPLOYEE_JOB as 工作 from DEPARTMENTS,EMPLOYEES
where DEPARTMENTS.DEPARTMENT_ID *= EMPLOYEES.DEPARTMENT_ID and EMPLOYEE_JOB = 'CLERK'
对于工资高于本部门平均水平的员工，列出部门号，姓名，工资，按部门号排序
select a.DEPARTMENT_ID as 部门号,a.EMPLOYEE_NAME as 姓名,a.SALARY as 工资 from EMPLOYEES as a
where a.SALARY>(select avg(SALARY) from EMPLOYEES as b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) order by a.DEPARTMENT_ID
对于EMPLOYEES，列出各个部门中平均工资高于本部门平均水平的员工数和部门号，按部门号排序
select count(a.SALARY) as 员工数,a.DEPARTMENT_ID as 部门号 from EMPLOYEES as a
where a.SALARY>(select avg(SALARY) from EMPLOYEES as b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) group by a.DEPARTMENT_ID order by a.DEPARTMENT_ID
对于EMPLOYEES中工资高于本部门平均水平，人数多与1人的，列出部门号，人数，按部门号排序
select count(a.EMPLOYEE_ID) as 员工数,a.DEPARTMENT_ID as 部门号,avg(SALARY) as 平均工资 from EMPLOYEES as a
where (select count(c.EMPLOYEE_ID) from EMPLOYEES as c where c.DEPARTMENT_ID = a.DEPARTMENT_ID and c.SALARY>(select avg(SALARY) from EMPLOYEES as b where c.DEPARTMENT_ID = b.DEPARTMENT_ID))>1
group by a.DEPARTMENT_ID order by a.DEPARTMENT_ID
对于EMPLOYEES中低于自己工资至少5人的员工，列出其部门号，姓名，工资，以及工资少于自己的人数
view sourceprint?
select a.DEPARTMENT_ID,a.EMPLOYEE_NAME,a.SALARY,(select count(b.EMPLOYEE_NAME) from EMPLOYEES as b where b.SALARY < a.SALARY) as 人数 from EMPLOYEES as a
where (select count(b.EMPLOYEE_NAME) from EMPLOYEES as b where b.SALARY<a.SALARY)>5

++++++取出数据库后10条数据++++++++
一种方法是数据库记录倒序排序，然后用limit 10子句获取10条。
 SELECT title AS TITLE FROM news ORDER BY id DESC LIMIT 10;
也可以取得最大记录的id，然后在WHERE子句减去10。
SELECT temp.title as 标题 FROM news AS temp WHERE news_id > (SELECT MAX(id) FROM news) - 10;


+++++++mysql_real_escape_string() 函数+++++++++++
mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。
保护数据库的安全――对即将运行于数据库的SQL语句进行安全性预处理.

常见数据库端口号 
MySQL: 3306
SQL Server: 1433
Oracle: 1521

常见协议端口号 
HTTP: 80
FTP: 20用于数据连接, 21用于端口连接
SSH: 22
Telnet: 23
HTTPS: 443

使用心得：
SQL语句用双引号，其中的值都用单引号，例如"INSERT INTO gril SET money='{$iMaxMoney}',age='18′"
用mysqli扩展代替mysql扩展
用mysqli_real_escape_string和mysqli_escape_string处理传出sql语句中的变量
用mysqli_set_charset(mysqli->set_charset)代替 query "SET NAMES"
联合查询(JOIN)之前，考虑下各个表的数据量，不合适的话应该分开查，尤其是有缓存可用的时候
很多地方需要记录发生时间，但不是每一个表都需要，同样，不是每一个表都需要一个自增量作主键
很多时候为integer类型加上unsigned是很好的
INERT DELEYED、INSERT IGNORE、SELECT DISTINCT…这种语句通常有意想不到的好效果
varchar类型并不是不能超过255长度，而是超过了255，这个字段就不能建立索引了，所以，看你的实际需要了


使用ip2long() 和long2ip()函数来把IP地址转化成整型存储到数据库里。
这种方法把存储空间降到了接近四分之一(char(15)的15个字节对整形的4个字节)，
计算一个特定的地址是不是在一个区段内页更简单了， 而且加快了搜索和排序的速度
(虽然有时仅仅是快了一点)。


+++++++++Mysql如何导入大SQL数据文件++++++
1、修改配置文件：一般默认配置是：1048576/1024/1024 = 1M
windows中修改my.ini文件，在linux中修改my.cnf文件.
C:\Documents and Settings\All Users\Application Data\MySQL\MySQL Server 5.5\my.ini(安装mysql时的,指定的数据文件目录)
修改max_allowed_packet值:
max_allowed_packet=500M;//根据情况选择
修改配置文件后,重启mysql
重启mysql后,在查看修改后的max_allowed_packet值
2、指定字符集编码：登录时指定字符集编码
mysql -uroot -P3308 -p123456 - -default-character-set=utf8 (-P是指指定端口号)
3、导入sql：最后通过source命令，即可成功导入:
source  E:ydj\test.sql


+++++++9个MySQL面试题++++++
1、如何确定 MySQL 是否处于运行状态？
Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status。
然后看看输出即可。
2、如何开启或停止 MySQL 服务？
运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务。
3、如何通过 Shell 登入 MySQL？
运行命令 mysql -u root -p
4、如何列出所有数据库？
运行命令 show databases;
5、如何切换到某个数据库并在上面工作？
运行命令 use database_name; 键入名为 database_name 的数据库。
6、如何列出某个数据库内所有表？
在当前数据库运行命令 show tables;
7、如何获取表内所有 Field 对象的名称和类型？
运行命令 describe table_name;
8、如何删除表？
运行命令 drop table table_name;
9、如何删除数据库？
运行命令 drop database database-name;
10、如何修改Root密码？
修改root密码对于某些特定设置是必不可少的，修改命令如下：
// 使用mysqladmin的password命令来修改（4.1格式）
$mysqladmin -u root password [新口令]
// 旧的修改口令的方法
$mysqladmin -u root -p [旧口令] 新口令 [敲回车后输入新口令，然后回车]
// 使用mysql的命令
$mysql -u root -p
mysql> use mysql;
mysql> update user set password=新口令 where User = ‘用户名’;
mysql> flush privileges;
mysql> quit
